# 레디스의 기본 개념
>키-값 형태의 데이터 저장소로서 데이터는 항상 키에 연결돼어 있기 때문에 키를 식별자로 이용한다.

## 레디스의 자료 구조
### String
|key|value|
|---|---|
|hello|"world"|
- 레디스에서 가장 간단한 자료 구조
- 최대 `512MB`의 문자열 데이터 저장 가능
- 이진 데이터 포함 모든 종류의 문자열(JPEG, 바이트, HTTP 응답 값 등) `binary-safe`하게 처리
- 키와 값이 일대일로 연결되는 유일한 자료 구조

> **binary-safe하다?**
>
> 저장되는 데이터가 텍스트인지 바이너리인지 구분하지 않고, 그대로 저장하고 반환한다는 의미로
> 문자 인코딩, 널 문자, 바이너리 값(0x00, 0xFF... 등)에 대해 해석하거나 수정하지 않는다.
>
> 이런 이유로 실무에서는 파일 해시값, 암호화 토큰을 바이너리 문자열 그대로 저장하거나
> Protocol Buffer, Avro 등 바이너리 직렬화 데이터를 저장하는 등 모든 바이트 조합의 값을 key 또는 value로 사용 가능하며,
> 다음과 같은 특징 및 장점이 있다.
> - 바이너리 안전 : 중간에 0x00이 있어도 lenth field로 정확히 구분
> - O(1) 길이 조회 : strlen() 불필요
> - 성능 최적화 : copy, append 등에서 reallocation 최소화
> - 동적 크기 조절 : realloc으로 size를 유연하게 변경
> - 메모리 파편화 감소 : fragmentation 방지 전략 적용
>
> 이렇게 동작이 가능한 이유는 [header][data][\0]의 구조를 가진 SDS(Simple Dynamic String)이라는 구조를 도입했기 때문이다.
> - hader : 문자열의 길이를 저장 (O(1) 조회)
> - data : 문자열 또는 바이너리 데이터 (0x00 포함 가능)
> - \0 : C 기반이므로 호환성을 위해 마지막에 NULL 포함
> 즉, Redis의 String은 실제 데이터 앞에 길이를 저장한 메모리 블록(legnth-prefixed)으로 되어 있다.

#### GET & SET
```bash
127.0.0.1:6379> SET hello world
OK
127.0.0.1:6379> GET hello
"world"
```
키에 이미 존재하는 다른 값이 있는 경우 새로운 값으로 대체되며, 다른 형태의 자료 구조도 동일하게 동작한다.

#### NX
```bash
# NX 옵션

# 이미 키가 있는 경우
127.0.0.1:6379> SET hello newval NX
(nil)

# 키가 없는 경우
127.0.0.1:6379> SET test value NX
OK
```
`NX` 옵션은 지정한 키가 없는 경우에만 새로운 키를 저장한다.

#### XX
```bash
# XX 옵션

# 키가 이미 있는 경우
127.0.0.1:6379> SET hello newnew XX
OK

# 키가 없는 경우
127.0.0.1:6379> SET hello2 val XX
(nil)
```
`XX` 옵션은 키가 이미 있는 경우에만 새로운 값으로 덮어 쓰고, 새로운 키를 생성하지 않는다.

#### INCR & INCRBY
```bash
# INCR
127.0.0.1:6379> SET counter 100
OK
127.0.0.1:6379> INCR counter
(integer) 101
127.0.0.1:6379> INCR counter
(integer) 102

# INCRBY
127.0.0.1:6379> INCRBY counter 50
(integer) 152
```
- `INCR` : 저장된 데이터를 1씩 증가하며, 증가된 값을 반환
- `INCRBY` : 입력한 값만큼 데이터를 증가하며, 증가된 값을 반환

#### DECR & DECRBY
```bash
# DECR
127.0.0.1:6379> DECR counter
(integer) 151
127.0.0.1:6379> DECR counter
(integer) 150

# DECRBY
127.0.0.1:6379> DECRBY counter 200
(integer) -50
```
빼기를 수행할 때 사용한다.

>자료 구조에 저장된 숫자를 원자적으로 조작한다?
>
>INCR, INCRBY 등과 같은 커맨드를 이용하면 string 자료 구조에 저장된 숫자를 원자적으로 조작 가능하다.
>
>원자적이라는 것은 여러 클라이언트가 경쟁 상태를 발생시킬 일이 없음을 의미하며, 이미 실행한 커맨드가 무시되거나
>같은 커맨드가 중복 처리돼 수행 결과가 달라지는 일은 발생하지 않음을 뜻한다.
>
>즉, 데이터 충돌 없이 안전하게 증가/감소/변경 연산이 수행된다는 뜻이다. 어떻게 가능한 것일까?
>먼저 레디스는 싱글 스레드 모델이기 때문에 명령을 직렬로 처리하여 동시에 두 명령이 실행되지 않음을 보장(lock-free concurrency)한다.
>그리고 레디스의 명령은 내부적으로 항상 하나의 완전한 연산으로 취급되어 분할 실행이 불가능하다.
>
>이러한 이유로 springboot 등의 멀티 스레드 환경에서 레디스에 동시 요청을 보내도 네트워크 I/O 큐에 쌓고 순서대로 처리한다.

#### MSET & MGET
```bash
# MSET
127.0.0.1:6379> MSET a 10 b 20 c 30
OK

# MGET
127.0.0.1:6379> MGET a b c
1) "10"
2) "20"
3) "30"
```
`MSET`과 `MGET` 같은 커맨드를 적절히 사용 시 네트워크 통신 시간을 줄여 응답 속도를 확실하게 향상시킬 수 있다.

#### string 실무 활용 사례
- 세션 관리 : 서버 재시작, 클러스터 환경에서도 세션이 유지 가능하고, 직렬화 객체를 그대로 저장하여 사용
- Toekn 저장 : 단일 token store로 가장 많이 사용하며, expire 기능과 ultra-low latency 덕분에 대규모 트래픽 처리가 가능
- 분산 락(Distributed Lock) : 멀티 인스턴스 환경에서 빠르고 글로벌하게 동작하기 때문에 동시성 제어 시 사용
- Counter / Sequence 관리 : DB의 쿼리 대신 `global counter` 등을 이용하여 원자성 + 초고속 달성
- 캐시 : JSON 등 자주 읽는 데이터를 미리 저장하여 메모리 캐싱 달성

`string` 자료 구조는 읽기와 쓰기에 소요되는 시간이 O(1)으로 가장 빠르며, key-value만 있으면 사용이 가능하여 단순한 구조를 가진다.
또한, binary 데이터 저장도 가능하고, 만료 시간 등 설정이 가능하며, 분산 시스템에서 사용할 수 있는 Atomic 연산의 장점도 있다.
이러한 이유로 실무에서는 `string`이 가장 많이 사용된다.

### List
|key|value|
|---|---|
|mylist|[A, B, C, D...]|
- 레디스의 `list`는 순서를 가지는 문자열의 목록
- 하나의 list에 최대 42억여 개의 아이템 저장
- 일반적으로 스택과 큐로서 사용

> 어떤 list를 사용할까?
>
> redis 2.x 이하
> 
> doubly linked list(양방향 연결 리스트)로 구현되어 각 노드는 개별 값(문자열)을 가졌다.
> LPUSH, RPUSH, LPOP 등의 연산은 O(1)의 시간 복잡도를 가지고, 양방향에서 빠르게 삽입 및 삭제가
> 가능했지만 메모리 낭비가 심하고, CPU의 캐시 미스가 증가하는 단점이 있었다.
>
> redis 3.2 이상
> 
> quicklist(linked list + ziplist) 도입으로 노드 하나하나가 ziplist라는 compact array list를
> 포함하도록 변경되었다. quicklist는 linked list와 ziplist의 장점을 융합하였는데 다음과 같다.
> - linked list
>   - O(1) 양끝 삽입/삭제
>   - 매우 큰 리스트 처리 가능
>   - 리스트 중간 split 가능
> - ziplist
>   - 메모리 연속 할당 -> 캐시 히트 증가
>   - 포인터 오버헤드 감소
>   - 압축 및 빠른 순차 접근
> 이를 통해 메모리 사용량은 절감하고, 캐시 히트를 증가시켜 성능 향상을 달성하였다.(참고로 최신 버전에서는 ziplist -> listpack으로 변경)

#### LPUSH & RPUSH
```bash
# 기본 사용
127.0.0.1:6379> LPUSH mylist E
(integer) 4
127.0.0.1:6379> RPUSH mylist A
(integer) 5

# 여러 아이템 한번에 저장
127.0.0.1:6379> LPUSH mylist A B C
(integer) 8
```
- `LPUSH` : 왼쪽에 데이터 추가
- `RPUSH` : 오른쪽에 데이터 추가

#### LRANGE
```bash
# 모든 요소
127.0.0.1:6379> LRANGE mylist 0 -1
1) "E"
2) "E"
3) "A"
4) "syusyu"
5) "A"

# 특정 범위
LRANGE mylist 0 2
1) "E"
2) "E"
3) "A"
```
- 가장 앞쪽 아이템 0
- 가장 마지막 아이템 -1

#### LPOP
```bash
# 가장 앞쪽 아이템 하나만 제거
127.0.0.1:6379> LPOP mylist
"C"

# 갯수 지정
127.0.0.1:6379> LPOP mylist 5
1) "B"
2) "A"
3) "E"
4) "E"
5) "A"
```
- `LPOP`만 사용한 경우 지정된 리스트의 가장 앞쪽 데이터만 꺼내오고 출력
- 숫자까지 지정한 경우 해당 갯수만큼 제거 후 출력

#### LTRIM
```bash
127.0.0.1:6379> LRANGE mylist 0 -1
1) "syusyu"
2) "A"
127.0.0.1:6379> LTRIM mylist 0 0
OK
127.0.0.1:6379> LRANGE mylist 0 -1
1) "syusyu"
```
인자로 전달된 첫 번째 숫자와 두 번째 숫자의 범위에 속하지 않은 아이템은 모두 삭제하고, 반환하지는 않는다.

#### LPUSH + LTRIM으로 고정된 길이 큐 유지
`LPUSH`로 요소를 등록하고, 동시에 지정한 범위를 벗어나는 경우 해당 아이템을 제거하는 `LTRIM`을 사용하면
고정된 길이의 큐를 쉽게 유지할 수 있다.

```bash
127.0.0.1:6379> LPUSH logdata 0 1 2 3 4
(integer) 5
127.0.0.1:6379> LTRIM logdata 0 999
OK
```
`LTRIM`은 해당 인덱스가 없는 경우 아무런 동작이 일어나지 않고, 해당 인덱스에 아이템이 있는 경우에만 삭제한다.
`list`에서는 꼬리(tail)의 데이터를 삭제하는 작업이 O(1)으로 동작하기 때문에 효율적인 동작이 보장된다.

#### LINSERT
```bash
127.0.0.1:6379> LRANGE logdata 0 -1
1) "4"
2) "3"
3) "2"
4) "1"
5) "0"
# 3 앞에 2를 추가
127.0.0.1:6379> LINSERT logdata BEFORE 3 2
(integer) 6
127.0.0.1:6379> LRANGE logdata 0 -1
1) "4"
2) "2"
3) "3"
4) "2"
5) "1"
6) "0"
127.0.0.1:6379>
```
`LINSERT`는 원하는 데이터의 앞이나 뒤에 데이터를 추가할 수 있으며, O(n)으로 동작한다.

#### LSET
```bash
127.0.0.1:6379> LSET logdata 1 99
OK
127.0.0.1:6379> LRANGE logdata 0 -1
1) "4"
2) "99"
3) "3"
4) "2"
5) "1"
6) "0"
```
`LSET`은 지정한 인덱스의 데이트를 신규 입력 데이터로 덮어 쓴다. 인덱스의 범위가 벗어난 경우 에러를 반환한다.

#### LINDEX
```bash
# 인덱스에 데이터가 없는 경우
127.0.0.1:6379> LINDEX logdata 99
(nil)

# 있는 경우
127.0.0.1:6379> LINDEX logdata 1
"99"
```
`LINDEX`는 원하는 인덱스의 데이터를 호출한다.

#### 삭제 방법
```bash
# DEL
127.0.0.1:6379> DEL mylist
(integer) 1

# LTRIM
127.0.0.1:6379> LTRIM logdata 0 -1
OK
```
- `DEL` : 키 자체를 삭제하여 메모리에서 완전히 해제한다. 가장 빠르고 권장되는 방법이다.
- `LTRIM` : 의도적으로 범위를 지정하여 list를 비우는 작업 key는 남아있지만 아이템은 0개인 상태이다.

#### list 실무 활용 사례
주로 순서가 중요하고, 양 끝 삽입/삭제가 빠른 특성을 활용하는 곳에 자주 사용된다.
- 작업 큐(Task Queue, 가장 대표적) : 작업을 큐에 넣고, 별도의 consumer worker가 꺼내서 비동기로 처리
  - 이메일 발송 대기열
  - 문자 발송 대기열
  - 이미지 변환 작업 큐
  - 대용량 배치 작업 스케줄링 등
- 알림 / 메세지 버퍼 : 사용자별 알림 메세지 Stack으로 사용하며, 실시간 push 알림(최근 10건 유지) 등에 사용
- 로그, 이벤트, 트래킹 히스토리 저장 등 사용 : FIFO 또는 LIFO 히스토리 저장에 가장 적합하게 사용
- 프로세스 간 메시지 전달 시 사용

`list`는 양쪽 삽입/삭제 성능이 우수하여 Queue 또는 Stack 패턴에 최적화 되어 있으며, 순서 보장을 통해 FIFO, LIFO에 모두 이용된다.
또한, `BRPOP`을 이용하여 Blocking pop이 지윈되어 다른 작업이 올 때까지 blocking을 유지할 수 있다.

### Hash
### Set
### sorted Set
### Hyperloglog
### Geospatial
### Stream

---

## 레디스에서 키를 관리하는 법
### 키의 자동 생성과 삭제
### 키와 관련된 커맨드
