# 레디스의 기본 개념
>키-값 형태의 데이터 저장소로서 데이터는 항상 키에 연결돼어 있기 때문에 키를 식별자로 이용한다.

## 레디스의 자료 구조
### String
|key|value|
|---|---|
|hello|"world"|
- 레디스에서 가장 간단한 자료 구조
- 최대 `512MB`의 문자열 데이터 저장 가능
- 이진 데이터 포함 모든 종류의 문자열(JPEG, 바이트, HTTP 응답 값 등) `binary-safe`하게 처리
- 키와 값이 일대일로 연결되는 유일한 자료 구조

> **binary-safe하다?**
>
> 저장되는 데이터가 텍스트인지 바이너리인지 구분하지 않고, 그대로 저장하고 반환한다는 의미로
> 문자 인코딩, 널 문자, 바이너리 값(0x00, 0xFF... 등)에 대해 해석하거나 수정하지 않는다.
>
> 이런 이유로 실무에서는 파일 해시값, 암호화 토큰을 바이너리 문자열 그대로 저장하거나
> Protocol Buffer, Avro 등 바이너리 직렬화 데이터를 저장하는 등 모든 바이트 조합의 값을 key 또는 value로 사용 가능하며,
> 다음과 같은 특징 및 장점이 있다.
> - 바이너리 안전 : 중간에 0x00이 있어도 lenth field로 정확히 구분
> - O(1) 길이 조회 : strlen() 불필요
> - 성능 최적화 : copy, append 등에서 reallocation 최소화
> - 동적 크기 조절 : realloc으로 size를 유연하게 변경
> - 메모리 파편화 감소 : fragmentation 방지 전략 적용
>
> 이렇게 동작이 가능한 이유는 [header][data][\0]의 구조를 가진 SDS(Simple Dynamic String)이라는 구조를 도입했기 때문이다.
> - hader : 문자열의 길이를 저장 (O(1) 조회)
> - data : 문자열 또는 바이너리 데이터 (0x00 포함 가능)
> - \0 : C 기반이므로 호환성을 위해 마지막에 NULL 포함
> 즉, Redis의 String은 실제 데이터 앞에 길이를 저장한 메모리 블록(legnth-prefixed)으로 되어 있다.

#### GET & SET
```bash
127.0.0.1:6379> SET hello world
OK
127.0.0.1:6379> GET hello
"world"
```
키에 이미 존재하는 다른 값이 있는 경우 새로운 값으로 대체되며, 다른 형태의 자료 구조도 동일하게 동작한다.

#### NX
```bash
# NX 옵션

# 이미 키가 있는 경우
127.0.0.1:6379> SET hello newval NX
(nil)

# 키가 없는 경우
127.0.0.1:6379> SET test value NX
OK
```
`NX` 옵션은 지정한 키가 없는 경우에만 새로운 키를 저장한다.

#### XX
```bash
# XX 옵션

# 키가 이미 있는 경우
127.0.0.1:6379> SET hello newnew XX
OK

# 키가 없는 경우
127.0.0.1:6379> SET hello2 val XX
(nil)
```
`XX` 옵션은 키가 이미 있는 경우에만 새로운 값으로 덮어 쓰고, 새로운 키를 생성하지 않는다.

#### INCR & INCRBY
```bash
# INCR
127.0.0.1:6379> SET counter 100
OK
127.0.0.1:6379> INCR counter
(integer) 101
127.0.0.1:6379> INCR counter
(integer) 102

# INCRBY
127.0.0.1:6379> INCRBY counter 50
(integer) 152
```
- `INCR` : 저장된 데이터를 1씩 증가하며, 증가된 값을 반환
- `INCRBY` : 입력한 값만큼 데이터를 증가하며, 증가된 값을 반환

#### DECR & DECRBY
```bash
# DECR
127.0.0.1:6379> DECR counter
(integer) 151
127.0.0.1:6379> DECR counter
(integer) 150

# DECRBY
127.0.0.1:6379> DECRBY counter 200
(integer) -50
```
빼기를 수행할 때 사용한다.

>자료 구조에 저장된 숫자를 원자적으로 조작한다?
>
>INCR, INCRBY 등과 같은 커맨드를 이용하면 string 자료 구조에 저장된 숫자를 원자적으로 조작 가능하다.
>
>원자적이라는 것은 여러 클라이언트가 경쟁 상태를 발생시킬 일이 없음을 의미하며, 이미 실행한 커맨드가 무시되거나
>같은 커맨드가 중복 처리돼 수행 결과가 달라지는 일은 발생하지 않음을 뜻한다.
>
>즉, 데이터 충돌 없이 안전하게 증가/감소/변경 연산이 수행된다는 뜻이다. 어떻게 가능한 것일까?
>먼저 레디스는 싱글 스레드 모델이기 때문에 명령을 직렬로 처리하여 동시에 두 명령이 실행되지 않음을 보장(lock-free concurrency)한다.
>그리고 레디스의 명령은 내부적으로 항상 하나의 완전한 연산으로 취급되어 분할 실행이 불가능하다.
>
>이러한 이유로 springboot 등의 멀티 스레드 환경에서 레디스에 동시 요청을 보내도 네트워크 I/O 큐에 쌓고 순서대로 처리한다.

#### MSET & MGET
```bash
# MSET
127.0.0.1:6379> MSET a 10 b 20 c 30
OK

# MGET
127.0.0.1:6379> MGET a b c
1) "10"
2) "20"
3) "30"
```
`MSET`과 `MGET` 같은 커맨드를 적절히 사용 시 네트워크 통신 시간을 줄여 응답 속도를 확실하게 향상시킬 수 있다.

#### string 실무 활용 사례
- 세션 관리 : 서버 재시작, 클러스터 환경에서도 세션이 유지 가능하고, 직렬화 객체를 그대로 저장하여 사용
- Toekn 저장 : 단일 token store로 가장 많이 사용하며, expire 기능과 ultra-low latency 덕분에 대규모 트래픽 처리가 가능
- 분산 락(Distributed Lock) : 멀티 인스턴스 환경에서 빠르고 글로벌하게 동작하기 때문에 동시성 제어 시 사용
- Counter / Sequence 관리 : DB의 쿼리 대신 `global counter` 등을 이용하여 원자성 + 초고속 달성
- 캐시 : JSON 등 자주 읽는 데이터를 미리 저장하여 메모리 캐싱 달성

`string` 자료 구조는 읽기와 쓰기에 소요되는 시간이 O(1)으로 가장 빠르며, key-value만 있으면 사용이 가능하여 단순한 구조를 가진다.
또한, binary 데이터 저장도 가능하고, 만료 시간 등 설정이 가능하며, 분산 시스템에서 사용할 수 있는 Atomic 연산의 장점도 있다.
이러한 이유로 실무에서는 `string`이 가장 많이 사용된다.

### List
|key|value|
|---|---|
|mylist|[A, B, C, D...]|
- 레디스의 `list`는 순서를 가지는 문자열의 목록
- 하나의 list에 최대 42억여 개의 아이템 저장
- 일반적으로 스택과 큐로서 사용

> 어떤 list를 사용할까?
>
> redis 2.x 이하
> 
> doubly linked list(양방향 연결 리스트)로 구현되어 각 노드는 개별 값(문자열)을 가졌다.
> LPUSH, RPUSH, LPOP 등의 연산은 O(1)의 시간 복잡도를 가지고, 양방향에서 빠르게 삽입 및 삭제가
> 가능했지만 메모리 낭비가 심하고, CPU의 캐시 미스가 증가하는 단점이 있었다.
>
> redis 3.2 이상
> 
> quicklist(linked list + ziplist) 도입으로 노드 하나하나가 ziplist라는 compact array list를
> 포함하도록 변경되었다. quicklist는 linked list와 ziplist의 장점을 융합하였는데 다음과 같다.
> - linked list
>   - O(1) 양끝 삽입/삭제
>   - 매우 큰 리스트 처리 가능
>   - 리스트 중간 split 가능
> - ziplist
>   - 메모리 연속 할당 -> 캐시 히트 증가
>   - 포인터 오버헤드 감소
>   - 압축 및 빠른 순차 접근
> 이를 통해 메모리 사용량은 절감하고, 캐시 히트를 증가시켜 성능 향상을 달성하였다.(참고로 최신 버전에서는 ziplist -> listpack으로 변경)

#### LPUSH & RPUSH
```bash
# 기본 사용
127.0.0.1:6379> LPUSH mylist E
(integer) 4
127.0.0.1:6379> RPUSH mylist A
(integer) 5

# 여러 아이템 한번에 저장
127.0.0.1:6379> LPUSH mylist A B C
(integer) 8
```
- `LPUSH` : 왼쪽에 데이터 추가
- `RPUSH` : 오른쪽에 데이터 추가

#### LRANGE
```bash
# 모든 요소
127.0.0.1:6379> LRANGE mylist 0 -1
1) "E"
2) "E"
3) "A"
4) "syusyu"
5) "A"

# 특정 범위
LRANGE mylist 0 2
1) "E"
2) "E"
3) "A"
```
- 가장 앞쪽 아이템 0
- 가장 마지막 아이템 -1

#### LPOP
```bash
# 가장 앞쪽 아이템 하나만 제거
127.0.0.1:6379> LPOP mylist
"C"

# 갯수 지정
127.0.0.1:6379> LPOP mylist 5
1) "B"
2) "A"
3) "E"
4) "E"
5) "A"
```
- `LPOP`만 사용한 경우 지정된 리스트의 가장 앞쪽 데이터만 꺼내오고 출력
- 숫자까지 지정한 경우 해당 갯수만큼 제거 후 출력

#### LTRIM
```bash
127.0.0.1:6379> LRANGE mylist 0 -1
1) "syusyu"
2) "A"
127.0.0.1:6379> LTRIM mylist 0 0
OK
127.0.0.1:6379> LRANGE mylist 0 -1
1) "syusyu"
```
인자로 전달된 첫 번째 숫자와 두 번째 숫자의 범위에 속하지 않은 아이템은 모두 삭제하고, 반환하지는 않는다.

#### LPUSH + LTRIM으로 고정된 길이 큐 유지
`LPUSH`로 요소를 등록하고, 동시에 지정한 범위를 벗어나는 경우 해당 아이템을 제거하는 `LTRIM`을 사용하면
고정된 길이의 큐를 쉽게 유지할 수 있다.

```bash
127.0.0.1:6379> LPUSH logdata 0 1 2 3 4
(integer) 5
127.0.0.1:6379> LTRIM logdata 0 999
OK
```
`LTRIM`은 해당 인덱스가 없는 경우 아무런 동작이 일어나지 않고, 해당 인덱스에 아이템이 있는 경우에만 삭제한다.
`list`에서는 꼬리(tail)의 데이터를 삭제하는 작업이 O(1)으로 동작하기 때문에 효율적인 동작이 보장된다.

#### LINSERT
```bash
127.0.0.1:6379> LRANGE logdata 0 -1
1) "4"
2) "3"
3) "2"
4) "1"
5) "0"
# 3 앞에 2를 추가
127.0.0.1:6379> LINSERT logdata BEFORE 3 2
(integer) 6
127.0.0.1:6379> LRANGE logdata 0 -1
1) "4"
2) "2"
3) "3"
4) "2"
5) "1"
6) "0"
127.0.0.1:6379>
```
`LINSERT`는 원하는 데이터의 앞이나 뒤에 데이터를 추가할 수 있으며, O(n)으로 동작한다.

#### LSET
```bash
127.0.0.1:6379> LSET logdata 1 99
OK
127.0.0.1:6379> LRANGE logdata 0 -1
1) "4"
2) "99"
3) "3"
4) "2"
5) "1"
6) "0"
```
`LSET`은 지정한 인덱스의 데이트를 신규 입력 데이터로 덮어 쓴다. 인덱스의 범위가 벗어난 경우 에러를 반환한다.

#### LINDEX
```bash
# 인덱스에 데이터가 없는 경우
127.0.0.1:6379> LINDEX logdata 99
(nil)

# 있는 경우
127.0.0.1:6379> LINDEX logdata 1
"99"
```
`LINDEX`는 원하는 인덱스의 데이터를 호출한다.

#### 삭제 방법
```bash
# DEL
127.0.0.1:6379> DEL mylist
(integer) 1

# LTRIM
127.0.0.1:6379> LTRIM logdata 0 -1
OK
```
- `DEL` : 키 자체를 삭제하여 메모리에서 완전히 해제한다. 가장 빠르고 권장되는 방법이다.
- `LTRIM` : 의도적으로 범위를 지정하여 list를 비우는 작업 key는 남아있지만 아이템은 0개인 상태이다.

#### list 실무 활용 사례
주로 순서가 중요하고, 양 끝 삽입/삭제가 빠른 특성을 활용하는 곳에 자주 사용된다.
- 작업 큐(Task Queue, 가장 대표적) : 작업을 큐에 넣고, 별도의 consumer worker가 꺼내서 비동기로 처리
  - 이메일 발송 대기열
  - 문자 발송 대기열
  - 이미지 변환 작업 큐
  - 대용량 배치 작업 스케줄링 등
- 알림 / 메세지 버퍼 : 사용자별 알림 메세지 Stack으로 사용하며, 실시간 push 알림(최근 10건 유지) 등에 사용
- 로그, 이벤트, 트래킹 히스토리 저장 등 사용 : FIFO 또는 LIFO 히스토리 저장에 가장 적합하게 사용
- 프로세스 간 메시지 전달 시 사용

`list`는 양쪽 삽입/삭제 성능이 우수하여 Queue 또는 Stack 패턴에 최적화 되어 있으며, 순서 보장을 통해 FIFO, LIFO에 모두 이용된다.
또한, `BRPOP`을 이용하여 Blocking pop이 지윈되어 다른 작업이 올 때까지 blocking을 유지할 수 있다.

### Hash
|key|value|
|---|---|
|Product|name -> iw, TypeId -> 334, Version -> 1.0|
- 필드-값 쌍을 가진 아이템의 집합
- 하나의 `hash` 자료 구조 내에서 아이템은 필드-값 쌍으로 저장
- 하나의 `hash` 내에서 유일
- 필드와 값 모두 문자열 데이터로 저장
- 동적으로 다양한 필드 추가 가능

#### HSET
```bash
127.0.0.1:6379> HSET Product Name "PRO1" TypeID 35
(integer) 2
```
`HSET`은 아이템을 저장할 때 사용하며 한 번에 하나 이상의 필드-값 쌍을 저장 가능하다.

#### HGET & HMGET & HGETALL
```bash
# HGET
127.0.0.1:6379> HGET Product Name
"PRO1"

# HMGET
127.0.0.1:6379> HMGET Product Name TypeID
1) "PRO1"
2) "35"

#HGETALL
127.0.0.1:6379> HGETALL Product
1) "Name"
2) "PRO1"
3) "TypeID"
4) "35"
```
- `HGET` : 키와 함께 필드를 입력
- `HMGET` : 키와 함께 복수 개의 필드 입력
- `HGETALL` : 키만 입력하면 모든 필드-값 쌍을 차례로 반환

#### HKEYS & HVALS
```bash
# HKEYS
127.0.0.1:6379> HKEYS product
1) "Name"
2) "Price"

# HVALS
127.0.0.1:6379> HVALS product
1) "test"
2) "3000"
```
- `HKEYS` : 모든 필드 이름 조회
- `HVALS` : 모든 값 조회

#### 그 외 커맨드
```bash
# HEXISTS
127.0.0.1:6379> HEXISTS product Name
(integer) 1

# HDEL
127.0.0.1:6379> HDEL product Price
(integer) 1

# HLEN
127.0.0.1:6379> HLEN product
(integer) 1

# HINCRBY
127.0.0.1:6379> HINCRBY product count 50
(integer) 51
```
- `HEXISTS` : 데이터에 해당 필드가 존재하는지 확인
- `HDEL` : 특정 필드 제거
- `HLEN` : 데이터의 필드 수 조회
- `HINCRBY` : 숫자 데이터 atomic 연산

#### `hash` 실무 활용 사례
- 사용자 프로필 캐싱 : DB 조회 없이 빠르게 조회가 가능하고, 구조화된 데이터의 빈번한 읽기/쓰기에 적합
- Session Data 저장 : 세션 정보를 필드-값으로 나눠서 관리 가능
- 다중 속성 캐싱 : string의 경우 전체 JSON이 필요하지만 hash의 경우 필요한 필드만 부분 조회 가능

`hash`는 구조화된 데이터 저장에 특화되어 부분 업데이트 및 조회에 사용이 가능하고, 압축률이 좋아 메모리의 효율적 사용이 가능하다.
또한, 필요한 필드만 읽고 쓰는 과정에서 네트워크 I/O의 부하를 줄여주며, 부분적 필드에 원자성 보장이 가능한 연산을 지원한다.

### Set
|key|value|
|---|---|
|myset|(A, B, C, D...)|
- 정렬되지 않은 문자열의 모음
- 교집합, 합집합, 차집합 등 집합 연산과 관련한 커맨드 제공
- 관계 계산 및 유일한 원소를 구해야하는 등의 경우에 사용

#### SADD
```bash
127.0.0.1:6379> SADD myset A
(integer) 1

# 중복된 데이터는 1개만 저장
127.0.0.1:6379> SADD myset B D C D
(integer) 3
```
이미 `set`에 존재하는 데이터는 중복 저장하지 않는다.

#### SMEMBERS
```bash
127.0.0.1:6379> SMEMBERS myset
1) "A"
2) "B"
3) "D"
4) "C"
```
저장된 전체 아이템을 출력하는데 데이터를 저장한 순서와 관계없이 출력된다.

#### SREM & SPOP
```bash
# 특정 아이템 제거
127.0.0.1:6379> SREM myset B
(integer) 1

# 랜덤 아이템 제거 후 출력
127.0.0.1:6379> SPOP myset
"A"

127.0.0.1:6379> SMEMBERS myset
1) "D"
2) "C"
```
- `SREM` : 특정 아이템을 제거
- `SPOP` : 랜덤으로 하나의 아이템을 반환하는 동시에 해당 아이템 삭제

> SPOP에 의해 랜덤으로 삭제되면 불편하지 않을까?
>
> 순서가 보장되어야 하는 기능에서 set을 사용하여 큐를 구현한다면 당연히 문제가 될 수 있다.
>
> 다만, 랜덤 추출이 요구되는 시스템, 예를 들어 이벤트 추첨이나 온라인 게임 랜덤 아이템 드롭 등의 경우에는
> 랜덤성이 오히려 기능상 필수이기 때문에 적합하게 사용될 수 있다.
>
> 이런 이유로 순서가 보장되어야 하거나 특정 아이템이 제거되어야 하는 경우는 SREM을 사용하고,
> 랜덤성을 요구하는 경우에만 SPOP을 활용한다.

#### 집합 커맨드
```bash
# 아이템 추가
127.0.0.1:6379> SADD set:111 A B C D E
(integer) 5
127.0.0.1:6379> SADD set:222 D E F G H
(integer) 5

# 교집합
127.0.0.1:6379> SINTER set:111 set:222
1) "D"
2) "E"

# 합집합
127.0.0.1:6379> SUNION set:111 set:222
1) "A"
2) "B"
3) "C"
4) "D"
5) "E"
6) "F"
7) "G"
8) "H"

# 차집합
127.0.0.1:6379> SDIFF set:111 set:222
1) "A"
2) "B"
3) "C"
```
- `SINTER` : 교집합 아이템을 추출
- `SUNION` : 합집합 아이템을 추출
- `SDIFF` : 차집합 아이템을 추출

#### `set` 실무 활용 사례
- 사용자 권한 저장 : 같은 role을 여러 번 저장하지 않고, 고유한 값으로 저장하여 사용
- 태그 시스템 : 게시글에 대한 태그 중복을 방지하고, 빠른 조회가 가능
- 이벤트 참여 중복 방지 : 이벤트에 참여하는 유저의 정보가 중복되지 않도록 확인하는 경우 사용
- 실시간 Online 상태 관리 : 현재 접속자 수 조회 등을 조회하는 경우 표준처럼 사용

`set`은 insert 시 중복을 검사할 필요없이 자동으로 제거되며, membership check를 통해 O(1)의 속도를 보장한다.
또한, 다양한 집합 연산을 신속하게 처리가 가능하기 때문에 실무에서도 빠른 속도를 요구할 때 자주 사용되는 자료 구조이다.

### sorted Set
|key|value|
|---|---|
|score|user:B -> 100|
- 스코어 값에 따라 정렬되는 고유한 문자열의 집합
- 스코어-값 쌍을 이루며 저장될 때부터 스코어 값으로 정렬
- 스코어가 같다면 사전 순으로 정렬
- `set`과 유사하게 중복 없이 유일하게 저장
- `hash`와 유사하게 스코어로 연결
- 인덱스를 이용한 접근 가능(O(log(n))의 시간 복잡도)

#### ZADD
```bash
127.0.0.1:6379> ZADD score:220 100 user:B
(integer) 1
127.0.0.1:6379> ZADD score:220 200 user:A 100 user:c 150 user:D
(integer) 3
```
- 스코어-값 쌍으로 입력하여 저장하며, 스코어 값으로 자동 정렬
- 저장하고자 하는 데이터가 이미 `sorted set`에 있는 경우 스코어만 업데이트
- 키가 이미 존재하지만 다른 자료 구조라면 오류를 반환
- 배정밀도 부동소수점 숫자를 문자열로 표현한 값이어야 함

> 배정밀도 부동소수점 숫자란?
>
> double precision floating point number로 IEEE 754 표준의 64-bit floating point 형식으로
> score 값을 저장하고 비교한다는 의미이다.
>
> 정수뿐 아니라 소수, 실수, 매우 큰 숫자, 매우 작은 숫자 모두 정밀하게 저장하고 정렬할 수 있다는 의미로
> 약 ±1.8 × 10³⁰⁸의 충분히 넓은 범위의 숫자를 표현할 수 있다.
>
> 결론적으로 정수를 사용했을 때 확보하지 못하는 유연성을 확보하기 위해 배정밀도 부동소수점 숫자를 사용한다.

#### ZADD의 옵션
- XX : 아이템이 이미 존재하는 경우만 스코어를 업데이트
- NX : 아이템이 존재하지 않을 때에만 새로 삽입, 기존 아이템의 스코어를 업데이트 하지 않음
- LT : 새로운 값이 기존 값보다 작은 경우만 업데이트, 아이템이 없는 경우 새로 삽입
- GT : 새로운 값이 기존 값보다 큰 경우만 업데이트, LT와 같음

#### ZRANGE

**인덱스로 데이터 조회**
```bash
# 정상 출력
127.0.0.1:6379> ZRANGE score:220 0 -1 WITHSCORES
 1) "user:B"
 2) "100"
 3) "user:D"
 4) "150"
 5) "user:C"
 6) "200"
 7) "user:c"
 8) "200"
 9) "user:A"
10) "300"

# 역순 출력
127.0.0.1:6379> ZRANGE score:220 0 -1 WITHSCORES REV
 1) "user:A"
 2) "300"
 3) "user:c"
 4) "200"
 5) "user:C"
 6) "200"
 7) "user:D"
 8) "150"
 9) "user:B"
10) "100"
```
`WITHSCORES`를 통해 스코어와 값 모두 조회가 가능하다.

**스코어 범위로 데이터 조회**
```bash
# 정상 출력
127.0.0.1:6379> ZRANGE score:220 150 300 BYSCORE WITHSCORES
1) "user:D"
2) "150"
3) "user:C"
4) "200"
5) "user:c"
6) "200"
7) "user:A"
8) "300"

# 값 포함 X
127.0.0.1:6379> ZRANGE score:220 (150 300 BYSCORE WITHSCORES

# 조건 출력 : 150보다 높은 값
127.0.0.1:6379> ZRANGE score:220 150 +inf BYSCORE WITHSCORES

# 모든 스코어 범위 값 조회
127.0.0.1:6379> ZRANGE score:220 -inf +inf BYSCORE WITHSCORES

# 스코어 이용 아이템 역순 조회
127.0.0.1:6379> ZRANGE score:220 +inf 200 BYSCORE WITHSCORES REV
```
- `BYSCORE`를 통해서 스코어를 이용한 조회가 가능
- 값을 포함하지 않고 싶은 경우 `(`를 추가
- `+inf`, `-inf`를 이용하여 특정 값보다 크거나 작은 값 출력

**사전 순으로 데이터 조회**
```bash
127.0.0.1:6379> ZRANGe mysrotedset (b (f BYLEX
1) "banana"
2) "candy"
3) "dream"
4) "egg"
```
- `BYLEX` : 사전식 순서를 이용해 특정 아이템 조회 가능
- `(` or `[` 문자가 없는 경우 `ERR min or max not valid string range item`에러 발생
- `- + BYLEX` : 모든 sorted set의 데이터 조회
- `ASCII` 바이트 값을 따르기 때문에 한글도 정렬 가능

#### `sorted set` 실무 활용 사례
`sorted set`은 자동 정렬 및 O(log(n))의 성능 덕분에 실시간으로 정렬과 검색이 동시에
필요한 데이터 처리에서 많이 활용된다.
- 실시간 랭킹 시스템 : 전자상거래, 광고 순위 시스템 등에서 우선 순위 분석을 위해 자주 사용
- 멀티 인스턴스 시스템에서 분산 작업 큐 역할로 사용
- 예약 메시지 전송 : 예약 시간을 스코어로 사용하여 예약된 메세지 전송

실시간 정렬과 검색이 가능하며, 매우 빠른 삽입 및 검색 속도를 가지고 있기 때문에 정렬 + 조회가
동시에 필요한 모든 서비스에서 실무 표준으로 사용되고 있다.

### 비트맵
|key|value|
|---|---|
|bitmap|00100010(0~7), 00100010(8~15)...|
- 독자적인 자료 구조는 아니며 string이 확장한 형태
- 2의 32 제곱의 비트를 가지고 있는 비트맵 형태
- 저장 공간을 획기적으로 줄일 수 있음

#### SETBIT & GETBIT
```bash
127.0.0.1:6379> SETBIT mybitmap 2 1
(integer) 0
127.0.0.1:6379> GETBIT mybitmap 2
(integer) 1
```

#### BITFIELD & BITCOUNT
```bash
127.0.0.1:6379> BITFIELD bitmap SET u1 7 1 SET u1 10 1 SET u1 14 1
1) (integer) 0
2) (integer) 0
3) (integer) 0
127.0.0.1:6379> BITCOUNT bitmap
(integer) 3
127.0.0.1:6379>
```

#### 비트맵 실무 활용 사례
비트맵은 내부적으로 `byte array (8bit = 1byte)`로 저장된다.
이러한 특성을 이용해 수십~수천만 boolean 값을 `ultra-low memory`로 빠르게 처리하는 경우 강력한 선택지로 작용한다.

실제로 1억 개의 boolean을 `list`로 변환하는 경우 100MB의 용량을 사용한다.
반면에 비트맵으로 바꿀 경우 12.5MB만으로도 1억 개의 boolean을 저장 가능하다.
- 출석 체크 시스템 : 사용자들의 아이디를 1로 set하여 사용자들의 출석 상태를 체크
- 하루 방문자 체크 : 하루가 지난 다음 `BITCOUNT`로 방문자 수 바로 추출하여 사용

비트맵은 메모리 효율적 측면이 다른 자료 구조에 비해 장점으로 부각되어 실무에서 많이 사용된다.
특히, 대용량 boolean tracking과 초고속 처리는 비트맵의 가장 큰 장점이다.

### Hyperloglog
|key|value|
|---|---|
|hyperloglog|내부적으로 데이터 변경 처리(집합 형태)|
- 원소 개수인 카디널리티를 추정할 수 있는 자료 구조
- 중복되지 않는 고유한 값을 집계할 때 유용하게 사용
- 데이터 자체를 저장하지 않고 자체적인 방법으로 변경하여 처리
- 데이터 개수에 구애받지 않고, 계속 일정한 메모리 유지 가능
- 하나의 자료 구조에 최대 12KB 크기를 가짐
- 최대 2의 64 제곱개의 아이템을 저장 가능

#### PFADD & PFCOUNT
```bash
127.0.0.1:6379> PFADD members 123
(integer) 1
127.0.0.1:6379> PFADD members 500
(integer) 1
127.0.0.1:6379> PFCOUNT members
(integer) 2
```

#### hyperloglog 실무 활용 사례
- 하루 방문 사용자 수 중 중복 사용자 계산 : 근사치에 대한 유일한 값을 제공
- 대규모 이벤터 참여자 수 추적 : 중복 sumbit 방지가 필요하지 않음으로 낮은 메모리로 효율 극대화

주로 정확한 수치가 요구될 떄는 `set`을 이용하고, 근사치에 해당하는 수치가 요구될 때 `hyperloglog`를 사용한다.

### Geospatial
### Stream

---

## 레디스에서 키를 관리하는 법
### 키의 자동 생성과 삭제
### 키와 관련된 커맨드
