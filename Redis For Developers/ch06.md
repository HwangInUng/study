# 레디스를 메세지 브로커로 사용하기
>메세지 브로커는 모듈 간 서로 탄탄한 상호 작용을 보장하기 위한 메시징 솔루션이다.
- 모듈 간의 통신에서는 되도록 비동기 통신을 사용하여 통신 불가능 시 바로 장애가 발생하지 않도록 보장
- 보낸 메시지를 어딘가에 쌓아 둔 뒤 나중에 처리할 수 있는 채널을 만듦

## 메시징 큐와 이벤트 스트림
|구분|메시징 큐|이벤트 스트림|
|---|---|---|
|데이터 생성|생산자(producer)|발행자(publisher)|
|데이터 수신|소비자(consumer)|구독자(subcriber)|
|방향성|데이터를 직접푸시하며, 메시징 큐에 각각 데이터를 푸시|특정 저장소에 하나의 메세지를 보낼 수 있고, 소비자들은 스트림에서 같은 메시지를 풀하기 때문에 데이터 복제 불필요|
|영속성|데이터를 읽어갈 때 큐에서 데이터 삭제|저장소 설정에 따라 특정 기간 동안 저장 유지|
|확인 시기|새로운 소비자 추가 시 새롭게 추가된 시점 이후 이벤트만 확인|데이터 생산 시 구독자를 지정하지 않기 때문에 이전 데이터의 히스토리 확인 가능|
|용도|1:1 상황에서 동작 지시|n:n 상황|

### 레디스를 메세지 브로커로 사용하기
- 레디스의 pub/sub을 이용
- 한 번 체널 전체에 전파된 뒤 삭제되는 일회성의 특징을 가짐
- 메시지 전달에 대한 응답 정보 등은 보장되지 않음
- `fire-and-forget` 패턴이 필요한 경우 유용하게 사용

>fire-and-forget 패턴이란?
>
>어떤 작업을 실행하고 그 결과에 대한 응답을 기다리지 않고 바로 다음 코드를 실행하는 것을 의미하며,
>신뢰성이 보장되어야 하는 경우에는 사용하지 말아야 한다.

---

## 레디스의 pub/sub
>레디스 노드에 접근 가능한 모든 클라이언트는 발행자와 구독자가 될 수 있으며, 최소한의 메세지 전달 기능만 제공하기 때문에 메타데이터는 알 수 없다.

💻 **조회 명령어**
|명령어|설명|
|---|---|
|PUBSUB CHANNELS|현재 구동중인 채널 목록 확인|
|PUBSUB NUMSUB <channel>|채널별 구독자 수 확인|
|UNSUBCRIBE|클라이언트가 채널 구독 해제|

### 메시지 publish하기
```bash
127.0.0.1:6379> PUBLISH event1 message1
(integer) 0
```
- 채널을 수신하고 있는 모든 서버들에 `message1` 전파
- 메시지 수신한 구독자 수를 반환
- 전달된 메시지는 레디스에 저장되지 않음

### 메시지 구독하기
**SUBCIRBE**
```bash
127.0.0.1:6379> SUBSCRIBE event1
1) "subscribe"
2) "event1"
3) (integer) 1
```
- `event1`에 대한 구독을 시작
- pub/sub과 관련되지 않은 명령어 사용 불가

**UNSUBCRIBE**
```bash
# 구독 해제
127.0.0.1:6379(subscribed mode)> UNSUBSCRIBE
```

**PSUBCRIBE**
```bash
127.0.0.1:6379> PSUBSCRIBE event-*
1) "psubscribe"
2) "event-*"
3) (integer) 1
```
- `*` 앞 부분으로 시작하는 모든 채널 수신
- 동시에 여러 문자열을 구독 가능
- `pmessage` 타입으로 전달되어 일반 수신 메시지 구독 방식과 구분
- 예를 들어 `SUBCRIBE` 방식의 채널과 그 채널을 포함하는 `PSUBCRIBE` 방식의 채널이 있다면 동시에 메시지 중복 수신

### 클러스터 구조에서의 pub/sub
- 레디스가 자체적으로 제공하는 데이터 분산 형태의 구조
- 메시지 발생 시 클러스터에 속한 모든 노드에 자동으로 전달
- 하나의 노드에 메시지를 발행하면 메시지는 모든 노드에 전파
- 다만, 모든 노드에 메세지가 전파되는 것은 데이터가 복제되므로 클러스터 환경의 핵심 목표와 부합하지 않음
- 이로 인한 네트워크 및 리소스 사용에 대한 부하가 발생

### sharded pub/sub
- 레디스의 7.0에서 도입하여 클러스터 환경의 pub/sub을 보완
- 각 채널은 슬롯에 매핑
- 같은 슬롯을 가지고 있는 노드 간에만 pub/sub 메시지를 전파
- `SPUBLISH` 커맨드를 이용하여 노드의 복제본에만 전달

**SPUBLISH**
```bash
127.0.0.1:6379> SPUBLISH apple a
(integer) 0
```
- 단일 노드 환경에서 사용이 가능
- 클러스터 환경을 구성했다면 리다이렉트 수행

**SSUBCRIBE**
```bash
127.0.0.1:6379> SSUBSCRIBE apple
1) "ssubscribe"
2) "apple"
3) (integer) 1
1) "smessage"
2) "apple"
3) "b"
```
- 반드시 `SSUBCRIBE`로 수신 가능

Sharded pub/sub는 불필요한 복제를 줄여 자원 절약이 가능하다.

---

## 레디스의 list를 메시징 큐로 사용하기
>tail과 head에서 데이터를 저장하고 조회할 수 있는 커맨드가 존재하기 때문에 메시징 큐를 직접 구현하여 사용할 수 있다는 장점이 있다.

### list의 EX 기능
애플리케이션에서 캐시 대상에 대한 존재 유무를 확인할 필요 없이 `RPUSHX` 커맨드를 사용하여 list에 이미 키가 존재하는 경우에 아이템을 추가할 수 있다.

```bash
# list에 해당 데이터가 없는 경우
127.0.0.1:6379> RPUSHX Timelinecache:userA test-data1
(integer) 0

# 키가 이미 존재하는 경우
127.0.0.1:6379> RPUSH Timelinecache:userA test-data1
(integer) 1
127.0.0.1:6379> RPUSHX Timelinecache:userA test-data2
(integer) 2
```

### list의 블로킹 기능
**이벤트 큐 동작 방식**
- 레디스를 이벤트 큐로 사용할 경우
- 이벤트 큐는 이벤트 루프를 사용
- 이벤트 루프는 새로운 이벤트가 없는 경우 일정 시간 대기 후 다시 이벤트 큐 확인
- 위 작업을 `폴링(polling)`이라고 함
- 폴링 인터벌로 인하여 이벤트를 즉시 처리할 수 없다는 단점 존재

**블로킹으로 해결**
- list에 데이터가 없는 경우 데이터가 들어올 때까지 대기
- 값이 들어오면 즉시 반환하거나 클라이언트가 설정한 타임아웃 시간만큼 대기한 후 `nil`값 반환
- 하나의 리스트에 대해 여러 클라이언트가 동시에 블로킹 가능하며,
- 가장 먼저 요청을 보낸 클라이언트에게 반환

**BRPOP & BLPOP**
```bash
127.0.0.1:6379> BRPOP queue:a 5
(nil)
(5.00s)
```
- 첫 번째 반환 값은 팝된 리스트의 키 값
- 두 번째 반환 값은 데이터의 값
- 동시에 여러 개의 리스트에서 대기할 수 있게 하기 위함

### list를 이용한 원형 큐
- 특정 아이템을 계속해서 반복 접근해야 하는 클라이언트
- 여러 개의 클라이언트가 병렬적으로 같은 아이템에 접근해야 하는 클라이언트

위 두가지 상황에서는 list를 원형 큐로 사용 가능하다.

**RPOPLPUSH**
```bash
127.0.0.1:6379> LPUSH clist A
(integer) 1
127.0.0.1:6379> LPUSH clist NB
(integer) 2
127.0.0.1:6379> LPUSH clist C
(integer) 3
127.0.0.1:6379> LRANGE clist 0 -1
1) "C"
2) "NB"
3) "A"
127.0.0.1:6379> RPOPLPUSH clist clist
"A"
127.0.0.1:6379> LRANGE clist 0 -1
1) "A"
2) "C"
3) "NB"
127.0.0.1:6379>
```

A가 가장 먼저 저장되어 우측 끝에 위치했을 때 `POP`을 수행하고, 다시 `PUSH`를 통해 가장 처음(왼쪽)으로 저장한다.

---

## Stream
>레디스 5.0에서 새로 추가된 자료 구조로 대용량, 대규모의 메시징 데이터를 빠르게 처리할 수 있도록 설계됐다.

**사용 목적**
- 백엔드 개발자들이 대량의 데이터를 효율적으로 처리하는 플랫폼으로 활용
- 데이터 엔지니어들이 여러 생산자가 생성한 데이터를 다양한 소비자가 처리할 수 있게 지원하는 데이터 저장소 및 중간 큐잉 시스템으로 사용

### 레디스의 Stream과 아파치 카프카
### 스트림이란?
연속적인 데이터의 흐름, 일정한 데이터 조각의 연속을 의미한다.
- 하나의 파일은 처리하는 것은 단어 또는 줄 단위로 데이터를 자르기 때문에 바이트 스트림 처리
- 계속되는 불규칙한 데이터를 연속으로 반복 처리하는 경우
- 그 외 애플리케이션 내부에서 데이터를 이동하는 경우

이러한 처리를 위해 스트리밍 플랫폼을 시스템 중심에 도입해 모든 데이터 처리를 스트리밍 플랫폼을 통해 수행하면
시스템이 마주한 다양한 문제를 조금 더 쉽게 해결할 수 있다.

### 데이터의 저장
**메시지의 저장과 식별**
|구분|카프카|레디스|
|---|---|---|
|저장 방식|토픽(각각의 분리된 스트림, 하나의 그룹)|stream 자료구조가 하나의 stream|
|메세지 식별|시퀀스 넘버(0부터 시작, 토픽 내 파티션 안에서만 유니크)|ID(시간과 관련된 유니크한 식별 값, 중복 x)|

레디스의 ID의 형태는 다음과 같다.
```bash
<millisecondsTime>-<sequenceNumber>
```
- 첫 번째는 저장될 시점의 레디스 노드 로컬 시간
- 두 번째는 같은 밀리세컨드에 저장된 데이터의 순서
- 시퀀스 번호는 64bit로 하나의 밀리세컨드 내에 생성할 수 있는 항목 수에는 제한이 없는 것과 마찬가지

결론적으로 레디스는 시간을 이용한 특정 데이터 검색이 가능하다.

**스트림 생성과 데이터 입력**
|구분|카프카|레디스|
|---|---|---|
|데이터 저장|토픽을 먼저 생성하고, 프로듀서를 이용해 메시지 전달|XADD 커맨드를 이용하여 데이터 저장과 동시에 생성|

```bash
127.0.0.1:6379> XADD Email * subject "first" body "hello"
"1749385200464-0"
```
- `*`은 레디스에서 지정한 타임스탬프 값을 의미하며, 사용자 지정이 필요할 경우 원하는 값을 입력(최소값은 0-1)
- 반환되는 값은 메시지를 유니크하게 식별 가능한 ID
- 데이터는 `hash` 자료 구조 처럼 필드-값 쌍으로 저장

**데이터의 조회**
|구분|카프카|레디스|
|---|---|---|
|조회 방식|특정 토픽을 실시간 리스닝|실시간 리스닝 or ID 이용 필요한 데이터 검색|
|조회 범위|기본은 리스닝을 시작한 시점부터 새로 저장되는 메시지 반환(설정 시 모든 데이터 조회 가능)|카프카와 유사|

실시간 데이터 조회
```bash
127.0.0.1:6379> XREAD BLOCK 0 STREAMs Email 0
1) 1) "Email"
   2) 1) 1) "1749385200464-0"
         2) 1) "subject"
            2) "first"
            3) "body"
            4) "hello"
```
- `XREAD`를 사용해 실시간 데이터 조회
- `BLOCK` 옵션 사용 시 처음부터 읽어오고, 새로운 메시지가 들어올 때까지 리스닝하며 대기
- `BLOCK 0`은 들어올 때까지 대기, `BLOCK 1000`은 1초 동안 연결 유지
- `STREAMS Email 0`은 스트림에 저장된 데이터 중 ID가 0보다 큰 값을 읽어오라는 의미
- `$`을 사용하면 커맨드를 실행한 이후 데이터부터 가져옴

특정한 데이터 조회
```bash
127.0.0.1:6379> XRANGE Email - +
1) 1) "1749385200464-0"
   2) 1) "subject"
      2) "first"
      3) "body"
      4) "hello"
2) 1) "1749385845922-0"
   2) 1) "subject"
      2) "second"
      3) "body"
      4) "2"
```
- `-`는 가장 작은 ID 값, `+`는 가장 마지막 ID 값
- `XREVRANGE`는 역순으로 데이터 조회
- 커맨드를 수행하는 시점에 stream에 저장된 모든 데이터를 반환한 뒤 종료
- 두 타임스탬프를 이용하거나 타임스탬프와 `-, +`를 조합하여 데이터 조회 가능
- `(`를 사용할 경우 이후 데이터부터 조회

**소비자와 소비자 그룹**
먼저 같은 데이터를 여러 소비자에게 전달하는 것을 팬아웃(fan-out)이라고 하는 것을 알고 가자.

|구분|카프카|레디스|
|---|---|---|
|팬아웃 방식|같은 토픽을 여러 개의 소비자가 읽어가게 함|XREAD 커맨드를 여러 소비자가 수행|
|순서 보장|X(소비자가 토픽에서 데이터를 소비할 때 파티션의 존재를 알지 못하기 때문에 전체 파티션에서 데이터를 읽음)|O(데이터 저장시 시간순과 고유 식별 값을 저장)|
|소비자 그룹|여러 소비자를 추가 가능하며, 토픽 내 파티션과 1:1로 연결|소비자 그룹 내의 한 소비자는 다른 소비자가 읽지 않은 데이터만을 읽어감|

레디스에서는 같은 데이터를 여러 소비자가 나눠서 가져가는 경우에 대하여 메세지를 병렬 처리함으로써 서비스의 처리 성능을 향상 시킬 수 있다.
- 한 번에 여러 이벤트를 병렬적으로 처리되도록 구성 가능
- 데이터가 저장될 때 부여받은 고유한 ID를 통해 순서가 항상 보장된 상태로 소비자에게 전달

소비자 그룹 생성
```bash
127.0.0.1:6379> XGROUP CREATE Email EmailServiceGroup $
OK
```
- `$`를 사용하여 현재 시점 이후 데이터부터 리스닝

소비자 그룹 데이터 조회
```bash
# 읽히지 않은 데이터가 없는 경우
127.0.0.1:6379> XREADGROUP GROUP EmailServiceGroup emailService1 COUNT 1 STREAMS Email >
(nil)

# 읽히지 않은 데이터가 있는 경우
127.0.0.1:6379> XADD Email * subject "third" body "3" # 데이터 추가
"1749386618506-0"
127.0.0.1:6379> XREADGROUP GROUP EmailServiceGroup emailService1 COUNT 1 STREAMS Email >
1) 1) "Email"
   2) 1) 1) "1749386618506-0"
         2) 1) "subject"
            2) "third"
            3) "body"
            4) "3"
```
- 소비자를 고유하게 식별할 수 있는 이름 지정
- 다른 소비자에게 읽히지 않은 데이터가 있다면 1개를 가져옴
- 없다면 `nil` 반환
- `COUNT`를 이용해 소비할 메시지 개수 직접 지정 가능
- `STREAM Email >`은 다른 소비자에게 전달되지 않았던 새로운 메시지를 전달하라는 의미이며, 0 또는 다른 ID 입력 시 입력한 ID보다 큰 ID 중 대기 list에 속하던 메시지 반환
- 소비자는 처음 언급 시 자동 생성
- 데이터를 읽어오는 동작 자체가 소비자 그룹에 영향을 미치기 때문에 일종의 쓰기 커맨드로 생각해야 함

>소비자 그룹은 stream의 상태를 나타내는 개념으로 간주
>
>카프카는 파티션이라는 개념을 이용해 부하 분산을 관리하지만 레디스는 소비자 그룹이라는 개념을 이용해 여러 소비자에게 데이터를 분산시킬 수 있다는 특징을 가진다.
>stream과 소비자 그룹을 독립적으로 동작 시킬 수 있어 소비자 그룹은 다수 존재할 수 있고, 각각 독립적으로 동작한다.
>
>하나의 소비자 그룹에서 여러 개의 stream을 리스닝하는 것도 가능하다.

**ACK와 보류 리스트**
예상치 못한 장애로 인해 시스템이 종료됐을 경우 이를 인지하고 재처리할 수 있는 기능이 필요하다.

- 각 소비자별로 읽어간 메시지에 대한 리스트를 새로 생성
- `last_delivered_id` 값으로 마지막으로 읽어간 데이터의 ID를 추적
- 데이터가 모두 처리된 경우 `ACK`를 보내며, `ACK`를 받은 메시지를 삭제
- 보류 리스트를 이용해 소비자가 처리한 데이터 파악이 가능

즉, 애플리케이션에서 stream을 사용해 소비자 그룹을 관리할 때 `XACK`를 소비자 측에서 주기적으로 전송하는 작업이 필요하다.

보류 중인 리스트 확인
```bash
127.0.0.1:6379> XPENDING Email EmailServiceGroup
1) (integer) 1
2) "1749386618506-0"
3) "1749386618506-0"
4) 1) 1) "emailService1"
      2) "1"
```
- 첫 번쨰는 ACK를 받지 못해 보류 중인 메시지의 개수
- 두 번째와 세 번째는 각각 보류 중인 메시지 ID의 최소 및 최대 값
- 그 뒤로 소비자별 보류 중인 리스트의 개수

ACK 반환으로 데이터 처리 알림
```bash
127.0.0.1:6379> XACK Email EmailServiceGroup 1749386618506-0
(integer) 1

# 이후 조회
127.0.0.1:6379> XPENDING Email EmailServiceGroup
1) (integer) 0
2) (nil)
3) (nil)
4) (nil)
```

📌 레디스 stream의 메시지 보증 전략
- `at most once`
  - 메시지를 최소 한 번 보내는 것을 의미
  - 문제가 생겨 서비스 다운 시 `ACK`를 이미 전달하여 처리하지 못한 데이터 유실 가능
  - 빠른 응답이 필요한 경우 사용
- `at least once`
  - 메시지를 모두 처리한 뒤 `ACK` 응답
  - `ACK` 전송 전 소비자가 종료되는 상황 발생 가능
  - 이미 처리한 이미지를 한 번 더 처리하게 되는 상황이 발생 할 수 있음
  - 멱등함이 보장되는 서비스라면 괜찮지만 그렇지 않은 경우 문제 발생
- `exactly once`
  - 무조건 한 번씩 전송되는 것을 보장한다는 의미
  - 추가적인 기능이 필요할 수 있음(set 등의 추가 자료 구조)
 
**메시지의 재할당**
장애 복구가 제대로 수행되지 않는 경우 다른 소비자가 보류 중인 메시지를 대신 처리해야 하기 때문에 `XCLAIM` 커맨드를 이용하여 메시지 소유권 전환이 가능하다.

```bash
127.0.0.1:6379> XCLAIM Email EmailServiceGroup emailService1 3600000 id
```
- `min-idle-time`이라는 최소 대기 시간을 지정
- 소유권을 변경할 수 있는 대기 시간을 지정하여 중복으로 다른 소비자에게 할당되는 것을 방지
- 먼저 실행된 커맨드가 있다면 메시지의 보류 시간이 즉시 0으로 재설정되어 중복 할당을 방지

메세지의 자동 재할당은 `XAUTOCLAIM` 커맨드를 이용하여 할당 대기 중인 다음 메세지의 ID를 반환하는 방식으로 동작하기 때문에 반복적 호출을 통해 자동 재할당이 가능하다.
메시지의 수동 재할당은 각 메시지가 보유한 `counter`라는 값을 이용해 특정 값으로 설정하여 해당 수준에 도달하면 다른 stream으로 보내어 처리가 가능하다.

**stream 상태 확인**
|구분|명령어|
|---|---|
|stream 명령어 확인|XINFO HELP|
|특정 소비자 그룹에 속한 소비자의 정보|XINFO consumers <key> <group>|
|전체 소비자 그룹 list|XINFO GROUPS <key>|
|stream 자체 정보|XINFO STREAM <key>|
