# 레디스를 메세지 브로커로 사용하기
>메세지 브로커는 모듈 간 서로 탄탄한 상호 작용을 보장하기 위한 메시징 솔루션이다.
- 모듈 간의 통신에서는 되도록 비동기 통신을 사용하여 통신 불가능 시 바로 장애가 발생하지 않도록 보장
- 보낸 메시지를 어딘가에 쌓아 둔 뒤 나중에 처리할 수 있는 채널을 만듦

## 메시징 큐와 이벤트 스트림
|구분|메시징 큐|이벤트 스트림|
|---|---|---|
|데이터 생성|생산자(producer)|소비자(consumer)|
|데이터 수신|발행자(publisher)|구독자(subcriber)|
|방향성|데이터를 직접푸시하며, 메시징 큐에 각각 데이터를 푸시|특정 저장소에 하나의 메세지를 보낼 수 있고, 소비자들은 스트림에서 같은 메시지를 풀하기 때문에 데이터 복제 불필요|
|영속성|데이터를 읽어갈 때 큐에서 데이터 삭제|저장소 설정에 따라 특정 기간 동안 저장 유지|
|확인 시기|새로운 소비자 추가 시 새롭게 추가된 시점 이후 이벤트만 확인|데이터 생산 시 구독자를 지정하지 않기 때문에 이전 데이터의 히스토리 확인 가능|
|용도|1:1 상황에서 동작 지시|n:n 상황|

### 레디스를 메세지 브로커로 사용하기
- 레디스의 pub/sub을 이용
- 한 번 체널 전체에 전파된 뒤 삭제되는 일회성의 특징을 가짐
- 메시지 전달에 대한 응답 정보 등은 보장되지 않음
- `fire-and-forget` 패턴이 필요한 경우 유용하게 사용

>fire-and-forget 패턴이란?
>
>어떤 작업을 실행하고 그 결과에 대한 응답을 기다리지 않고 바로 다음 코드를 실행하는 것을 의미하며,
>신뢰성이 보장되어야 하는 경우에는 사용하지 말아야 한다.

---

## 레디스의 pub/sub
>레디스 노드에 접근 가능한 모든 클라이언트는 발행자와 구독자가 될 수 있으며, 최소한의 메세지 전달 기능만 제공하기 때문에 메타데이터는 알 수 없다.

💻 **조회 명령어**
|명령어|설명|
|---|---|
|PUBSUB CHANNELS|현재 구동중인 채널 목록 확인|
|PUBSUB NUMSUB <channel>|채널별 구독자 수 확인|
|UNSUBCRIBE|클라이언트가 채널 구독 해제|

### 메시지 publish하기
```bash
127.0.0.1:6379> PUBLISH event1 message1
(integer) 0
```
- 채널을 수신하고 있는 모든 서버들에 `message1` 전파
- 메시지 수신한 구독자 수를 반환
- 전달된 메시지는 레디스에 저장되지 않음

### 메시지 구독하기
**SUBCIRBE**
```bash
127.0.0.1:6379> SUBSCRIBE event1
1) "subscribe"
2) "event1"
3) (integer) 1
```
- `event1`에 대한 구독을 시작
- pub/sub과 관련되지 않은 명령어 사용 불가

**UNSUBCRIBE**
```bash
# 구독 해제
127.0.0.1:6379(subscribed mode)> UNSUBSCRIBE
```

**PSUBCRIBE**
```bash
127.0.0.1:6379> PSUBSCRIBE event-*
1) "psubscribe"
2) "event-*"
3) (integer) 1
```
- `*` 앞 부분으로 시작하는 모든 채널 수신
- 동시에 여러 문자열을 구독 가능
- `pmessage` 타입으로 전달되어 일반 수신 메시지 구독 방식과 구분
- 예를 들어 `SUBCRIBE` 방식의 채널과 그 채널을 포함하는 `PSUBCRIBE` 방식의 채널이 있다면 동시에 메시지 중복 수신

### 클러스터 구조에서의 pub/sub


### sharded pub/sub

---

## 레디스의 list를 메시징 큐로 사용하기
### list의 EX 기능
### list의 블로킹 기능
### list를 이용한 원형 큐

---

## Stream
### 레디스의 Stream과 아파치 카프카
### 스트림이란?
### 데이터의 저장
