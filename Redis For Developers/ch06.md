# 레디스를 메세지 브로커로 사용하기
>메세지 브로커는 모듈 간 서로 탄탄한 상호 작용을 보장하기 위한 메시징 솔루션이다.
- 모듈 간의 통신에서는 되도록 비동기 통신을 사용하여 통신 불가능 시 바로 장애가 발생하지 않도록 보장
- 보낸 메시지를 어딘가에 쌓아 둔 뒤 나중에 처리할 수 있는 채널을 만듦

## 메시징 큐와 이벤트 스트림
|구분|메시징 큐|이벤트 스트림|
|---|---|---|
|데이터 생성|생산자(producer)|소비자(consumer)|
|데이터 수신|발행자(publisher)|구독자(subcriber)|
|방향성|데이터를 직접푸시하며, 메시징 큐에 각각 데이터를 푸시|특정 저장소에 하나의 메세지를 보낼 수 있고, 소비자들은 스트림에서 같은 메시지를 풀하기 때문에 데이터 복제 불필요|
|영속성|데이터를 읽어갈 때 큐에서 데이터 삭제|저장소 설정에 따라 특정 기간 동안 저장 유지|
|확인 시기|새로운 소비자 추가 시 새롭게 추가된 시점 이후 이벤트만 확인|데이터 생산 시 구독자를 지정하지 않기 때문에 이전 데이터의 히스토리 확인 가능|
|용도|1:1 상황에서 동작 지시|n:n 상황|

### 레디스를 메세지 브로커로 사용하기
- 레디스의 pub/sub을 이용
- 한 번 체널 전체에 전파된 뒤 삭제되는 일회성의 특징을 가짐
- 메시지 전달에 대한 응답 정보 등은 보장되지 않음
- `fire-and-forget` 패턴이 필요한 경우 유용하게 사용

>fire-and-forget 패턴이란?
>
>어떤 작업을 실행하고 그 결과에 대한 응답을 기다리지 않고 바로 다음 코드를 실행하는 것을 의미하며,
>신뢰성이 보장되어야 하는 경우에는 사용하지 말아야 한다.

---

## 레디스의 pub/sub
>레디스 노드에 접근 가능한 모든 클라이언트는 발행자와 구독자가 될 수 있으며, 최소한의 메세지 전달 기능만 제공하기 때문에 메타데이터는 알 수 없다.

💻 **조회 명령어**
|명령어|설명|
|---|---|
|PUBSUB CHANNELS|현재 구동중인 채널 목록 확인|
|PUBSUB NUMSUB <channel>|채널별 구독자 수 확인|
|UNSUBCRIBE|클라이언트가 채널 구독 해제|

### 메시지 publish하기
```bash
127.0.0.1:6379> PUBLISH event1 message1
(integer) 0
```
- 채널을 수신하고 있는 모든 서버들에 `message1` 전파
- 메시지 수신한 구독자 수를 반환
- 전달된 메시지는 레디스에 저장되지 않음

### 메시지 구독하기
**SUBCIRBE**
```bash
127.0.0.1:6379> SUBSCRIBE event1
1) "subscribe"
2) "event1"
3) (integer) 1
```
- `event1`에 대한 구독을 시작
- pub/sub과 관련되지 않은 명령어 사용 불가

**UNSUBCRIBE**
```bash
# 구독 해제
127.0.0.1:6379(subscribed mode)> UNSUBSCRIBE
```

**PSUBCRIBE**
```bash
127.0.0.1:6379> PSUBSCRIBE event-*
1) "psubscribe"
2) "event-*"
3) (integer) 1
```
- `*` 앞 부분으로 시작하는 모든 채널 수신
- 동시에 여러 문자열을 구독 가능
- `pmessage` 타입으로 전달되어 일반 수신 메시지 구독 방식과 구분
- 예를 들어 `SUBCRIBE` 방식의 채널과 그 채널을 포함하는 `PSUBCRIBE` 방식의 채널이 있다면 동시에 메시지 중복 수신

### 클러스터 구조에서의 pub/sub
- 레디스가 자체적으로 제공하는 데이터 분산 형태의 구조
- 메시지 발생 시 클러스터에 속한 모든 노드에 자동으로 전달
- 하나의 노드에 메시지를 발행하면 메시지는 모든 노드에 전파
- 다만, 모든 노드에 메세지가 전파되는 것은 데이터가 복제되므로 클러스터 환경의 핵심 목표와 부합하지 않음
- 이로 인한 네트워크 및 리소스 사용에 대한 부하가 발생

### sharded pub/sub
- 레디스의 7.0에서 도입하여 클러스터 환경의 pub/sub을 보완
- 각 채널은 슬롯에 매핑
- 같은 슬롯을 가지고 있는 노드 간에만 pub/sub 메시지를 전파
- `SPUBLISH` 커맨드를 이용하여 노드의 복제본에만 전달

**SPUBLISH**
```bash
127.0.0.1:6379> SPUBLISH apple a
(integer) 0
```
- 단일 노드 환경에서 사용이 가능
- 클러스터 환경을 구성했다면 리다이렉트 수행

**SSUBCRIBE**
```bash
127.0.0.1:6379> SSUBSCRIBE apple
1) "ssubscribe"
2) "apple"
3) (integer) 1
1) "smessage"
2) "apple"
3) "b"
```
- 반드시 `SSUBCRIBE`로 수신 가능

Sharded pub/sub는 불필요한 복제를 줄여 자원 절약이 가능하다.

---

## 레디스의 list를 메시징 큐로 사용하기
>tail과 head에서 데이터를 저장하고 조회할 수 있는 커맨드가 존재하기 때문에 메시징 큐를 직접 구현하여 사용할 수 있다는 장점이 있다.

### list의 EX 기능
애플리케이션에서 캐시 대상에 대한 존재 유무를 확인할 필요 없이 `RPUSHX` 커맨드를 사용하여 list에 이미 키가 존재하는 경우에 아이템을 추가할 수 있다.

```bash
# list에 해당 데이터가 없는 경우
127.0.0.1:6379> RPUSHX Timelinecache:userA test-data1
(integer) 0

# 키가 이미 존재하는 경우
127.0.0.1:6379> RPUSH Timelinecache:userA test-data1
(integer) 1
127.0.0.1:6379> RPUSHX Timelinecache:userA test-data2
(integer) 2
```

### list의 블로킹 기능
**이벤트 큐 동작 방식**
- 레디스를 이벤트 큐로 사용할 경우
- 이벤트 큐는 이벤트 루프를 사용
- 이벤트 루프는 새로운 이벤트가 없는 경우 일정 시간 대기 후 다시 이벤트 큐 확인
- 위 작업을 `폴링(polling)`이라고 함
- 폴링 인터벌로 인하여 이벤트를 즉시 처리할 수 없다는 단점 존재

**블로킹으로 해결**
- list에 데이터가 없는 경우 데이터가 들어올 때까지 대기
- 값이 들어오면 즉시 반환하거나 클라이언트가 설정한 타임아웃 시간만큼 대기한 후 `nil`값 반환
- 하나의 리스트에 대해 여러 클라이언트가 동시에 블로킹 가능하며,
- 가장 먼저 요청을 보낸 클라이언트에게 반환

**BRPOP & BLPOP**
```bash
127.0.0.1:6379> BRPOP queue:a 5
(nil)
(5.00s)
```
- 첫 번째 반환 값은 팝된 리스트의 키 값
- 두 번째 반환 값은 데이터의 값
- 동시에 여러 개의 리스트에서 대기할 수 있게 하기 위함

### list를 이용한 원형 큐

---

## Stream
### 레디스의 Stream과 아파치 카프카
### 스트림이란?
### 데이터의 저장
