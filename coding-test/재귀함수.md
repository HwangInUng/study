## 재귀 함수
### 개념
>재귀 함수는 자기 자신을 호출하는 함수를 의미

### 자주 사용되는 알고리즘
문제를 더 작은 부분으로 나눠 반복적으로 해결하는 경우에 적합하여 다음과 같은 알고리즘에 사용된다.
- 분할 정복(Divide and Conquer) : 문제를 분할하여 각각 해결 후 합치는 과정으로 문제 해결
- 탐색(Search) : 트리 또는 그래프 같은 계층적 구조 탐색으로 문제 해결
- 이진 트리 순회(Binary Tree Traversal) : 트리의 노드를 재귀적으로 탐색하여 문제 해결
- 백트래킹(Backtacking) : 모든 가능한 해를 탐색하며 조건에 맞는 해를 찾아 문제 해결
- 동적 프로그래밍(Dynamic Programming, DP) : 중복된 부분 문제를 해결하고, 재귀를 메모이제션과 결합하여 문제 해결

위에서 나열된 알고리즘 외에도 문제를 단순화하거나 분할하여 효율적으로 해결하는데 사용된다.

### 구조
재귀 함수는 보통 두 가지 요소로 구성된다.
- 기저 조건(Base Case) : 재귀 호출을 멈추는 조건으로 이 조건이 없는 경우 무한히 호출
- 재귀 단계(Recursive Step) : 문제를 더 작게 나누어 자기 자신을 호출하는 단계

**코드**
```java
public int factorial(int n) {
  if(n == 0) { // 기저 조건
    return 1;
  }

  return n * factorial(n - 1); // 재귀 단계
}
```

### 장단점

**장점**
- 문제를 직관적이고 간결하게 표현 가능 -> 가독성 향상
- 복잡한 문제를 작은 문제로 나눠서 해결 가능 -> 디버깅 용이

**단점**
- 구현 실수가 발생하면 무한 루프에 빠지기 쉬움
- 함수 호출이 많은 경우 스택 오버플로우 발생
- 반복문으로 대체 가능한 경우 상대적으로 성능이 떨어짐

### 동작 흐름
재귀 함수는 자기 자신을 호출하기 때문에 동작의 흐름을 사람이 정확하게 파악하는게 다소 어려울 수 있다. 하지만 위에서 설명한 구조를 보면서 다시 생각해보면 그렇게 복잡하지 않을 수 있다.
- 재귀 호출을 멈추는 조건을 설정
- 문제를 작게 나누어 반복적 호출을 하는 로직을 작성

위의 항목을 작성할 때 컴퓨터의 사고방식을 생각하면서 작성해보자.
- 컴퓨터는 사람처럼 전체적인 그림을 그리면서 문제를 해결할 수 없다.
- 컴퓨터는 현재 시점의 문제 또는 상황만을 고려하여 해결한다.
- 즉, 로직을 수행할 때 마다 상황이 초기화된다고 인지하고 매번 동일한 행동을 반복하여 결과만 도출한다.

재귀 함수의 대표적인 예로 factorial()에 대한 코드를 보며 사람과 컴퓨터의 인식 차이에 대해 이해해보자.
**코드**
```java
// 호출
fatorial(5);

public int factorial(int n) {
  if(n == 0) { // 기저 조건
    return 1;
  }

  return n * factorial(n - 1); // 재귀 단계
}
```
사람의 경우에는 팩토리얼 함수의 동작 방식을 이해하고 있고, 최종적으로 도달해야하는 결과 값을 알기 때문에 흐름을 이해하여 최종 결과를 도출할 수 있다. 하지만 이렇게 사람이 이해하는 흐름은 재귀 함수 호출과는 인식의 차이가 발생한다.

컴퓨터는 전달받은 매개변수의 값을 확인하고, 내부 코드만 실행하는게 전부이다. 전체적인 흐름에 대해서는 관심이 없고, 현재 할당된 작업에 대해서 수행하여 결과를 도출하거나 다음 작업을 수행할 뿐이다.

이런 이유 때문에 사람의 머리로 재귀 함수의 호출이 어떻게 이루어지는이 이해하는데 다소 시간이 걸리고, 복잡한 것이다.

그렇다면 스택을 이용해서 좀 더 이해하기 쉽게 동작의 흐름을 알아보자.

**코드**
```java
public class FactorialExample {
    public static int factorial(int n) {
        if (n == 0) {  // 기저 조건
            return 1;
        }
        return n * factorial(n - 1);  // 재귀 호출
    }

    public static void main(String[] args) {
        System.out.println(factorial(4));  // 결과: 24
    }
}
```
위와 같이 fatorial(4)를 호출할 때 스택과 반환할 때 스택이 어떻게 흘러가는지 확인해보자.

```java
// 호출 스택 증가
factorial(4) -> 4 * factorial(3)
factorial(3) -> 3 * factorial(2)
factorial(2) -> 2 * factorial(1)
factorial(1) -> 1 * factorial(0)
factorial(0) -> 1 (기저 조건 도달)

// 반환 스택 감소
factorial(0) -> 1
factorial(1) -> 1 * 1 = 1
factorial(2) -> 2 * 1 = 2
factorial(3) -> 3 * 2 = 6
factorial(4) -> 4 * 6 = 24
```
재귀 함수는 결국 가장 최근에 호출한 함수를 반환하는 형태로 동작한다. 그리고 가장 최근에 호출한 함수를 반환하는 타이밍은 기저 조건을 통해 설정되는 것이다.
즉, 개발자가 재귀 함수 실행이 언제 멈추어야 하는지에 대한 조건만 명확히 고려한다면 호출의 흐름을 따라가는 것은 크게 어렵지 않을 수 있다.

### 정리
- 재귀 함수를 작성할 때 사람과 컴퓨터의 사고방식 차이를 명확히 인지하고 작성해야한다.
- 달리 말하면 재귀 함수 실행 시 현재 상황에 집중할 수 있는 코드를 작성한다.
- 재귀 함수의 기저 조건에 대한 고민이 필요하고, 명확한 기저 조건을 설정한다.
- 반복적으로 수행되는 재귀 단계 동작을 작은 문제를 통해 정확하게 파악하고 작성한다.
