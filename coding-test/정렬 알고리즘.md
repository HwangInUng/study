## 정렬 알고리즘
### 개념
>정렬 알고리즘은 원소들을 일정한 순서대로 정렬하는데 사용되는 알고리즘이다. 시간 복잡도와 메모리 사용량 등 여러 항목들을 고려하여 사용하는 것이 효율적이다.

### 고려사항
- 데이터 크기
  - 데이터 크기가 작은 경우 단순하고 구현이 쉬운 알고리즘을 선택하여 생산성 향상
  - 데이터 크기가 큰 경우 구현은 복잡하지만 시간 복잡도가 낮은 알고리즘을 선택하여 성능 향상
- 시간 복잡도
  - 최선/최악/평균 시간 복잡도를 비교
  - 이미 정렬된 상태에서 시간 복잡도 성능이 우수한 알고리즘 적용
- 공간 복잡도
  - 메모리 사용량이 제한적인 환경에서 제자리 정렬(in-place sorting)을 고려
  - 병합 정렬 등 추가 메모리를 사용해야하는 알고리즘 등은 메모리 사용량 제한 시 제외
- 정렬 안정성
  - 같은 값이 있는 경우 원래 순서를 유지해야하는 경우 안정성이 보장되는 알고리즘 선택
- 병렬화 가능성
  - 대량의 데이터 처리가 필요한 경우 병합 정렬 또는 분산 알고리즘 적용

### 종류
|구분|시간복잡도(최선/평균/최악)|공간복잡도|안정성|난이도|비고|
|:---:|:---:|:---:|:---:|:---:|:---:|
|버블정렬|O(n)/O(n²)/O(n²)|O(1)|O|하|단순하지만 비효율적|
|선택정렬|O(n²)/O(n²)/O(n²)|O(1)|X|하|데이터 이동 횟수가 적음|
|삽입정렬|O(n)/O(n²)/O(n²)|O(1)|O|하|거의 정렬된 데이터에 적합|
|병합정렬|O(n log n)/O(n log n)/O(n log n)|O(n)|O|중|대규모 데이터 정렬에 적합|
|퀵정렬|O(n log n)/O(n log n)/O(n²)|O(log n)|X|중|실제 환경에서 가장 빠름|
|힙정렬|O(n log n)/O(n log n)/O(n log n)|O(1)|X|중|메모리 효율적, 느린 경우 있음|

각 정렬 알고리즘이 효율적으로 동작하는 상황은 다음과 같다.
- 작은 데이터 : 삽입 정렬
- 랜덤 데이터 : 퀵 정렬
- 거의 정렬된 데이터 : 삽입 정렬
- 메모리 제한 상황 : 힙 정렬
- 병렬 처리 및 대규모 데이터 : 병합 정렬

### 세부내용
#### 버블 정렬 : Bubble Sort
인접한 두 요소를 비교하여 필요 시 교환하는 과정을 반복하는 방식으로 동작하여 가장 큰 값이 순차적으로 뒤로 이동한다.
작은 데이터셋 또는 정렬 알고리즘의 기본 개념을 설명할 때 사용된다.

**코드**
```java
void bubbleSort(int[] arr) {
  int n = arr.length;

  for(int i = 0; i < n; i++) {
    for(int j = 0; j < n - i; j++) {
      if(arr[j] > arr[j + 1]) {
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
}
```

#### 선택 정렬 : Selection Sort
매 단계마다 최소 또는 최대 값을 찾아 해당 위치로 이동시키는 방식으로 동작한다. 주로 기초 정렬 알고리즘을 이해하거나 학습 하기 위한 목적으로 사용된다.

**코드**
```java
void selectSort (int[] arr) {
    int n = arr.length;

    for(int i = 0; i < n - 1; i++) {
        // 현재 인덱스로 초기화
        int minIndex = i;
        for(int j = i + 1; j < n; j++) {
            // 현재 인덱스를 제외한 요소와 비교하며 최소값 갱신
            if(arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }

        // 갱신된 최소값의 위치를 변경
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
}
```

#### 삽입 정렬 : Insertion Sort
배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분의 원소를 정렬된 부분에 삽입하는 방식으로 동작한다. 데이터 셋이 이미 정렬된 상태에서 효율적으로 동작하지만 작은 데이터 셋에서는 효율적이지 않다.

**코드**
```java
void insertionSort(int[] arr) {
    int n = arr.length;
    
    // 반복문을 첫 번째 요소부터 시작
    for(int i = 1; i < n; i++) {
        int key = arr[i];
        // 이전 요소들의 인덱스 역할
        int prev = i - 1;

        // 0번째 요소까지 감소하며 이전 요소들이 현재 요소보다 크면
        // 이전 요소를 현재 요소로 변경하는 작업을 반복
        while (prev >= 0 && arr[prev] > key) {
            arr[prev + 1] = arr[prev];
            prev--;
        }

        // 요소들을 정렬한 후 현재 요소를 최종 위치에 삽입
        arr[prev + 1] = key;
    }
}
```

#### 병합 정렬 : Merge Srot
분할 정복(divide and conquer) 방법을 사용해서 배열을 반으로 나누어 각각 정렬 후 병합하는 방식으로 동작한다. 안정성이 보장되고, 일정한 성능을 보장하지만 추가적인 메모리 공간이 필요하다.

**코드**
```java
void mergeSort(int[] arr, int left, int right) {
    // 왼쪽 인덱스가 오른쪽 인덱스보다 작으면 수행
    if(left < right) {
        int mid = (left + right) / 2;
        
        // 재귀 호출을 통해 요소가 1개가 될 때까지 분할
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        // 병합 작업 수행
        // 요소가 1개가 되는 시점부터 합쳐지면서 동작
        merge(arr, left, mid, right);
    }

}

void merge(int[] arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    int[] leftArr = new int[n1];
    int[] rightArr = new int[n2];

    for(int i = 0; i < n1; i++) {
        leftArr[i] = arr[left + i];
    }

    for(int i = 0; i < n2; i++) {
        rightArr[i] = arr[mid + 1 + i];
    }

    // 왼쪽 요소와 오른쪽 요소를 비교하여 정렬
    int i = 0, j =0, k = left;
    while (i < n1 && j < n2) {
        arr[k++] = (leftArr[i] <= rightArr[j]) ? leftArr[i++] : rightArr[j++];
    }

    // 나머지 요소 삽입
    while (i < n1) {
        arr[k++] = leftArr[i++];
    }
    while (j < n2) {
        arr[k++] = rightArr[j++];
    }
}
```

#### 힙 정렬 : Heap Sort
최대 힙이나 최소 힙 자료구조를 이용하여 배열을 정렬하는 방식으로 동작한다. 항상 O(n log n)의 시간복잡도를 가지며, 추가 메모리 공간이 거의 필요하지 않는다.

**코드**
```java
void heapSort(int[] arr) {
    int n = arr.length;
    
    // 배열을 힙 구조로 변경하는 작업
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 최대 힙에서 루트를 배열 끝으로 이동시키는 작업
    // 첫 번째 요소와 마지막 요소를 교환 후
    // 힙 속성 유지를 위해 heapify() 호출
    for (int i = n - 1; i >= 0; i--) {
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        heapify(arr, i, 0);
    }
}

// 특정 서브트리에서 힙 속성을 유지하도록 보장
// i를 루트로 하는 서브트리가 최대 힙 속성을 가지도록 동작
void heapify(int[] arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    // 자식 노드 중 더 큰 값이 부모 노드로 변경
    if(left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    if(right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    // 부모 노드 변경 시
    // 부모와 자식 교환 후 힙 속성 유지
    if(largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;

        heapify(arr, n, largest);
    }
}
```

#### 퀵 정렬 : Quick Sort
분할 정복 방법을 사용해서 배열을 정렬하는 방식으로 피벗(pivot)을 기준으로 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 분할하며 정렬한다. 평균적으로는 빠르지만 안정성이 보장되지 않는다.

**코드**
```java
void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        // 분할된 배열 위치
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// 배열을 pivot 기준으로 정렬
int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    // pivot보다 작은 요소 인덱스 추적
    int smaller = (low - 1);

    for(int current = low; current < high; current++) {
        // 만족 시 작은 요소를 교환하여 왼쪽으로 이동
        if(arr[current] < pivot) {
            smaller++;
            int temp = arr[smaller];
            arr[smaller] = arr[current];
            arr[current] = temp;
        }
    }

    // pivot을 올바른 위치로 이동
    int temp = arr[smaller + 1];
    arr[smaller + 1] = arr[high];
    arr[high] = temp;

    // pivot의 최종 위치
    return smaller + 1;
}
```
