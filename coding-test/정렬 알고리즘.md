## 정렬 알고리즘
### 개념
>정렬 알고리즘은 원소들을 일정한 순서대로 정렬하는데 사용되는 알고리즘이다. 시간 복잡도와 메모리 사용량 등 여러 항목들을 고려하여 사용하는 것이 효율적이다.

### 고려사항
- 데이터 크기
  - 데이터 크기가 작은 경우 단순하고 구현이 쉬운 알고리즘을 선택하여 생산성 향상
  - 데이터 크기가 큰 경우 구현은 복잡하지만 시간 복잡도가 낮은 알고리즘을 선택하여 성능 향상
- 시간 복잡도
  - 최선/최악/평균 시간 복잡도를 비교
  - 이미 정렬된 상태에서 시간 복잡도 성능이 우수한 알고리즘 적용
- 공간 복잡도
  - 메모리 사용량이 제한적인 환경에서 제자리 정렬(in-place sorting)을 고려
  - 병합 정렬 등 추가 메모리를 사용해야하는 알고리즘 등은 메모리 사용량 제한 시 제외
- 정렬 안정성
  - 같은 값이 있는 경우 원래 순서를 유지해야하는 경우 안정성이 보장되는 알고리즘 선택
- 병렬화 가능성
  - 대량의 데이터 처리가 필요한 경우 병합 정렬 또는 분산 알고리즘 적용

### 종류
|구분|시간복잡도(최선/평균/최악)|공간복잡도|안정성|난이도|비고|
|:---:|:---:|:---:|:---:|:---:|:---:|
|버블정렬|O(n)/O(n²)/O(n²)|O(1)|O|하|단순하지만 비효율적|
|선택정렬|O(n²)/O(n²)/O(n²)|O(1)|X|하|데이터 이동 횟수가 적음|
|삽입정렬|O(n)/O(n²)/O(n²)|O(1)|O|하|거의 정렬된 데이터에 적합|
|병합정렬|O(n log n)/O(n log n)/O(n log n)|O(n)|O|중|대규모 데이터 정렬에 적합|
|퀵정렬|O(n log n)/O(n log n)/O(n²)|O(log n)|X|중|실제 환경에서 가장 빠름|
|힙정렬|O(n log n)/O(n log n)/O(n log n)|O(1)|X|중|메모리 효율적, 느린 경우 있음|

각 정렬 알고리즘이 효율적으로 동작하는 상황은 다음과 같다.
- 작은 데이터 : 삽입 정렬
- 랜덤 데이터 : 퀵 정렬
- 거의 정렬된 데이터 : 삽입 정렬
- 메모리 제한 상황 : 힙 정렬
- 병렬 처리 및 대규모 데이터 : 병합 정렬

### 세부내용
#### 버블 정렬 : Bubble Sort
인접한 두 요소를 비교하여 필요 시 교환하는 과정을 반복하는 방식으로 동작하여 가장 큰 값이 순차적으로 뒤로 이동한다.
작은 데이터셋 또는 정렬 알고리즘의 기본 개념을 설명할 때 사용된다.

**코드**
```java
public void bubbleSort(int[] arr) {
  int n = arr.length;

  for(int i = 0; i < n; i++) {
    for(int j = 0; j < n - i; j++) {
      if(arr[j] > arr[j + 1]) {
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
}
```

#### 선택 정렬 : Selection Sort
매 단계마다 최소 또는 최대 값을 찾아 해당 위치로 이동시키는 방식으로 동작한다. 주로 기초 정렬 알고리즘을 이해하거나 학습 하기 위한 목적으로 사용된다.
