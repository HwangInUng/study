## LinkeddList 정렬 - 기초
>Leetcode의 21.Merge Two Sroted Lists를 풀어보면서 부족한 부분이 있어서 다시 정리하고 넘어가려한다.

### 문제 설명
문제에서 최종적으로 요구하는 내용은 이미 오름차순으로 정렬된 2개의 LinkedList를 순서대로 병합하여 반환하는 것이며,
다음과 같은 고려사항이 주어진다.

- ListNode 타입의 파라미터 2개가 전달됨
- 2개의 Node를 하나의 정렬된 리스트로 구성
- Head 노드를 return

#### 부족한 부분 식별
여기서 내가 실수한 부분은 `리스트로 구성하여 반환하라`는 문구만 보고, `왜 리스트 형태가 아닌데 리스트로 구성해서 반환해야하지?`라는
생각을 했었다. 이 부분은 누가 보더라도 링크드 리스트에 대한 이해가 부족했다고 판단할 수 있다.

그래서 시간이 좀 소요되었지만 차분히 문제를 읽다가 막히는 부분은 지식이 부족하다고 인정하고, 이론적 내용을 참고하면서 해결해보았다.

먼저 파라미터로 전달되는 클래스를 분석했다.

**ListNode**
```java
public class ListNode {
  int val;
  ListNode next;

  // 기본 생성자
  ListNode () {}
  ListNode (int val) {
    this.val = val;
  }
  ListNode (int val, ListNode next) {
    this.val = val;
    this.next = next;
  }
}
```
ListNode는 단방향 LinkedList로 동작하며, 이전 노드에 대한 정보는 보유하지 않고 있다.
LinkedList의 특징은 다음과 같다.

- 인덱스를 통한 접근이 불가능하다.
- 노드 간의 참조를 보유하여 연결 정보를 구성한다.
- 데이터의 공간을 미리 할당할 필요가 없다.
- 검색 시 연결 정보를 찾는데 시간이 소요된다.
- 단방향으로 구현 시 연결 정보가 끊겨 안정성을 보장할 수 없다.

LinkedList에 대한 이론적인 부분을 찾아보고 문제를 다시 풀어보았다.

### 문제 해결 시 고려사항
문제를 해결하는데 다음과 같은 고려사항들이 존재했다.

- 파라미터들의 연결된 노드 길이가 다를 수 있다.
- 최소 0, 최대 50개의 노드 개수를 가진다.
- 위 조건은 둘 중 하나의 ListNode가 없을 수도 있고, 둘 다 없을 수도 있다.
- 길이가 다르기 때문에 한쪽이 먼저 종료된 이후의 결과를 처리해야한다.

위와 같은 고려사항을 해결하기 위해 다음과 같은 절차로 코드를 작성하기로 했다.

### 코드 작성
```java
class Solution {
  public ListNode mergeTwoLists (ListNode list1, ListNode list2) {
    // 1. 두 개 노드의 길이 확인
    if (노드1 null 여부) {}
    if (노드2 null 여부) {}

    // 2. 결과로 반환할 head 노드 생성
    ListNode 결과;
    // 3. 반복문을 수행하며, 다음 노드를 가리킬 노드 생성
    ListNode 다음노드;

    // 4. 노드1과 노드2가 null 아닐때까지 while 수행
    while (노드1 != null && 노드2 != null) {
      // 5. 대소 비교 후 연결 최신화
      if (노드 1이 더 큰 경우) {}
      else {} // 노드 2가 더 큰 경우

      // 6.
    }
  }
}
```
