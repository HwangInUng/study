## Union-Find 알고리즘
### 개념
>서로소 집합(Disjoint-Set) 알고리즘이라고도 불리며, 구체적으로 여러 개의 노드가 존재할 때 두 개의 노드를 선택해서 현재 이 노드가 서로 같은 집합에 속하는지 판별하는 알고리즘이다.

여기서 서로소 집합이란 서로 중복되지 않는 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조이다.

### 수행 과정
- 초기화(makeSet)
  - 각 노드를 하나의 집합으로 초기화시키는 과정으로 n = 8이라면 `{0},{1},{2}...{8}`처럼 유일한 원소를 가지는 집합으로 만드는 작업
- 합치기(union)
  - 찾고자 하는 두 개의 노드의 집합을 합치는 과정으로 2번과 3번 원소를 합친다면 `{0}, {1}, {2, 3}, ...{8}`처럼 합집합을 수행
- 찾기(find)
  - 주어진 원소 정보가 속한 집합의 대표를 반환하는 작업
 
집합은 루트 노드를 가질 수 있는 트리 구조를 사용하여 구현하는 것이 효과적이다.

### 예시
`n=8`이라고 가정하고, 다음과 같은 유니온 연산을 수행한 결과를 그림으로 알아보자. 노드의 시작은 1로 한다.

```java
union(1, 5);
union(8, 1);
union(3, 5);
union(6, 7);
union(4, 3);
union(2, 8);
```
#### 초기화
|노드 번호|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|
|부모|1|2|3|4|5|6|7|8|

#### 합치기

<img src='https://github.com/user-attachments/assets/c22fc0d1-3f30-4871-8a5d-53eec301052b' width=500/>

1. union(1, 5) : 5번 노드의 부모를 1번 노드로 설정

|노드 번호|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|
|부모|1|2|3|4|1|6|7|8|

2. union(8, 1) : 8번 노드의 부모를 1번 노드로 설정

|노드 번호|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|
|부모|1|2|3|4|1|6|7|1|

여기까지 수행하면 5번 노드와 8번 노드의 부모는 1번 노드로 동일하게된다.

3. union(3, 5) : 3번 노드의 부모를 5번 노드로 설정

하지만 여기서 5번 노드는 이미 1번이라는 부모 노드가 존재하기 때문에 find()를 통해 1번 노드를 반환해 3번 노드의 부모와 비교하여 더 작은 숫자로 설정한다.
3번 노드는 자신이 부모 노드로 지정되어 있기 때문에 1 < 3이 성립하므로 3번 노드의 부모는 1번 노드로 지정한다.

|노드 번호|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|
|부모|1|2|1|4|1|6|7|1|

여기까지 진행하면 1번 노드를 부모로 가지는 노드는 3, 5, 8번 노드이다.

4. union(6, 7) : 7보다 작은 숫자인 6을 부모 노드로 설정

|노드 번호|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|
|부모|1|2|1|4|1|6|6|1|
  
5. union(4, 3) : 4번 노드의 부모를 3번 노드로 설정

3번 노드는 이미 1번 노드를 부모로 가지고 있기 때문에 4번 노드의 부모도 1번 노드로 지정하게된다.

|노드 번호|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|
|부모|1|2|1|1|1|6|6|1|

여기까지 진행하면 집합은 다음과 같다.
- {1, 3, 5, 8, 4}
- {2}
- {6, 7}
 
6. union(2, 8) : 2번 노드의 부모를 8번 노드로 설정

8번 노드의 부모는 1번 노드이기 때문에 2번 노드의 부모도 1번 노드로 설정

|노드 번호|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|
|부모|1|1|1|1|1|6|6|1|

이렇게 모든 union()을 진행하면 위 사진과 같이 트리가 구성된다.

#### 찾기
그럼 위 과정에서 find()를 통해 부모 노드를 찾는 과정에 대해서 알아보자.

find() 함수는 현재 입력받은 원소를 배열에서 노드의 부모와 현재 원소가 같을때까지 재귀적으로 호출하여 값을 반환하는 방식으로 동작한다.
이와 같은 원리로 a, b 원소의 부모를 각각 find()를 통해 확인하여 같은 집합에 존재하는지 여부를 확인한다던지 union()을 통해 합치는 작업을 수행할 때 사용한다.

**코드**
```java
public int find(int[] arr, int x) {
  if(arr[x] == x) {
    return arr[x];
  }

  return arr[x] = find(arr, arr[x]);
}
```

### 알고리즘 코드
그렇다면 Union-Find 알고리즘의 전체적인 코드는 어떻게 구현되는지 Java를 사용하여 알아보자.

```java
public static void main(String[] args) {
    int n = 8;
    int[] parent = new int[n + 1];

    for(int i = 1; i <= n; i++) {
        parent[i] = i;
    }

    union(parent, 2, 4);
    union(parent, 5, 7);
    union(parent, 6, 8);
    union(parent, 8, 2);
    union(parent, 1, 3);
    union(parent, 3, 5);

    // 여기까지 구성된 집합
    // {2, 4, 6, 8}
    // {1, 3, 5, 7}

    if (find(parent, 3) != find(parent, 2)) {
        System.out.println("다름");
    }
}

public static int find (int[] parent, int x) {
    if(parent[x] == x) {
        return parent[x];
    }

    return parent[x] = find(parent, parent[x]);
}

public static void union (int[] parent, int a, int b) {
    int rootA = find(parent, a);
    int rootB = find(parent, b);

    if(rootA != rootB) {
        if(rootA < rootB) {
            parent[rootB] = rootA;
        } else {
            parent[rootA] = rootB;
        }
    }
}
```
---

### 정리
Union-Find 알고리즘은 O(m·α(n))의 시간복잡도를 가지며, a(n)는 아커만 함수의 역함수로 거의 상수에 가깝다. 이 말은 조금 어려우니 다르게 설명하면 다음과 같다.
- find() 연산을 통해 방문한 모든 노드의 부모를 직접 루트로 설정하여 연산의 트리 깊이를 줄여 효율적 수행이 가능하다.
- 트리의 높이가 낮은 트리를 높이가 높은 트리 아래에 병합하기 때문에 트리 높이를 최소화하여 효율성을 높인다.
- n개의 노드에 대해 m개의 연산을 수행하며 시간 복잡도는 O(m·α(n))이다.
- α(n)은 매우 느리게 증가하는 함수로 현실적인 입력 크기에서는 거의 상수에 가깝다.
