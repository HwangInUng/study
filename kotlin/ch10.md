## 10. 어노테이션과 리플렉션
> 미리 알지 못하는 임의의 클래스를 다루는 어노테이션과 리플렉션에 대해 알아보자.

- 어노테이션 : 라이브러리가 요구하는 의미를 클래스에게 부여
- 리플렉션 : 실행 시점에 컴파일러 내부 구조를 분석

### 10.1 어노테이션 선언과 적용
메타데이터를 선언에 추가하면 컴파일 시점이나 실행 시점에 적절한 처리가 가능하다.

#### 10.1.1 어노테이션 적용
- 적용하고자 하는 대상 앞에 사용
- @ + 어노테이션 이름으로 구성
- 함수, 클래스 등 여러 구성 요소에 사용 가능

**기본 문법 예시**
```kotlin
import org.junit.*

class MyTest {
  @Test fun testTrue() {
    Assert.assertTrue(true)
  }
}
```
코틀린에서는 `replaceWith` 파라미터를 이용해 이전 버전을 대신할 수 있는 패턴 제시를 할 수 있다.

```kotlin
// () 안에 인자를 전달
@Deprecated("Use removeAt (index) instead.", ReplaceWith("removeAt (index)"))
fun remove(index: Int) {...}
```

어노테이션의 인자로 원시 타입의 값, 문자열, enum, 클래스 참조, 다른 어노테이션 등 사용할 수 있으며 문법은 다음과 같다.

- 클래스 : `@MyAnnotation(Myclass::Class)`와 같이 `::class`를 이름 뒤에 사용
- 다른 어노테이션 : 인자로 들어가는 어노테이션 앞에 @를 제거
- 배열 : `arrayOf()`를 사용
  - 자바에서 선언한 어노테이션 클래스를 사용할 경우 value가 자동으로 가변 길이 인자로 변환
  - `@JavaAnnotationWithArrayValue("abc", "foo")`와 같이 `arrayOf()`를 사용하지 않아도 됨

**kotlin**
```kotlin
// 어노테이션 정의
annotation class MyAnnotation(val values: Array<String>)

@MyAnnotation(arrayOf("abc", "def")) // arrayOf()를 사용해야 함
fun myFunction() { }

// 코틀린에서 자바 어노테이션 사용 시
@JavaAnnotation("abc", "def") // arrayOf() 생략 가능
fun myFunction() { }
```

**java**
```java
// 어노테이션 정의
@interface MyAnnotation {
    // value를 가변인자로 인식
    String[] value();
}
// 배열 명시적의로 전달
@MyAnnotation({"abc", "def"}) // 배열을 명시적으로 전달
public void myFunction() { }

// 배열 암묵적으로 전달
@MyAnnotation("abc", "def") // 배열을 암묵적으로 전달
public void myFunction() { }
```

- 어노테이션 인자를 컴파일 시점에 알아야하기 때문에 임의의 프로퍼티를 인자로 지정 불가능
- `const` 변경자를 사용하여 프로퍼티를 어노테이션 인자로 사용
- 컴파일러는 `const`가 붙은 프로퍼티를 컴파일 시점 상수로 취급

```kotlin
// 상수로 취급
const val TEST_TIMEOUT = 100L
@Test(timeout = TEST_TIMEOUT) fun testMethod() {...}
```
- `const`는 파일의 맨 위 또는 ojbect 안에 선언
- 원시 타입 또는 String으로 초기화

#### 10.1.2 어노테이션 대상
코틀린과 자바 선언에 여러 대응이 발생하는 경우 명시적으로 어노테이션을 표시해야하는 경우가 있다.

- 코틀린 프로퍼티 : 자바 필드와 게터 선언과 대응
- 프로퍼티 변경 가능 : 세터와 대응
- 주 생성자 : 자바 생성자 파라미터와 대응

이런 경우 **사용 지점 대상** 선언으로 어노테이션을 붙일 요소를 지정한다.

- @ 기호와 어노테이션 이름 사이에 사용 지점 대상을 기입
- 콜론(:)으로 분리
- ex : `@get:Rule`

```kotlin
class HasTempFolder {
    // getter에 어노테이션 사용
    @get:Rule
    val folder = TemporaryFolder()
    
    @Test
    fun testUsingTempFolder() {...}
}
```

- 공개 필드나 메서드 앞에 어노테이션 사용
- 프로퍼티 앞에 어노테이션 사용 시 예외 발생
- 자바로 선언한 어노테이션의 경우 프로퍼티의 필드에 그 어노테이션이 붙음
- 코틀린은 프로퍼티에 직접 적용할 수 있는 어노테이션을 만들어야함

**사용 지점 대상 목록**
- `property` : 프로퍼티 전체, 자바에서 선언된 어노테이션에는 사용 불가
- `field` : 프로퍼티에 의해 생성되는 백킹 필드
- `get` : 게터
- `set` : 세터
- `receiver` : 확장 함수 및 프로퍼티의 수신 객체 파라미터
- `param` : 생성자 파라미터
- `setparam` : 세터 파라미터
- `delegate` : 위엄 프로퍼티의 위임 인스턴스를 담아둔 필드
- `file` : 파일 안에 선언된 최상위 함수 및 프로퍼티를 담은 클래스
  - package 선언 앞에서 파일의 최상위 수준에만 적용 가능

```kotlin
// property
// 자바와의 상호 운용성에 적합하지 않음
@property:Annotation
var myProperty: String = "Hello"

// field
// 컴파일된 자바 클래스에서 필드 레벨에 적용
@field:Annotation
var myField: String = "Hello"

// get & set
@get:Annotation
val myProperty: String = "Hello"
@set:Annotation
var myProperty: String = "Hello"

// receiver
// 수신 객체(String)에 적용
fun @receiver:Annotation String.customFunction() {
    println(this)
}

// param
// 자바로 변환 시 생성자 파라미터의 메타데이터에 포함
class MyClass(@param:Annotation val name: String)

// setparam
@setparam:Annotation
var myProperty: String = "Hello"

// delegate
// 인스턴스를 담는 백킹 필드에 적용
class MyDelegate {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String = "Hello"
    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {}
}

class MyClass {
    @delegate:Annotation
    val myProperty: String by MyDelegate()
}

// file
@file:Annotation
package my.package

fun topLevelFunction() {}
```

- 어노테이션 인자로 클래스 또는 함수 선언 외 임의 식을 허용

```kotlin
fun test(list: List<*>) {
  @Suppress("UNCHECKED_CAST")
  val strings = list as List<String>
  // ...
}
```

`@Volatile`, `@Strictfp` 어노테이션은 자바의 `volatile`과 `strictfp` 키워들 대신한다. 
다음 나열한 어노테이션 사용 시 코틀린 선언을 자바에 노출시키는 방법 변경이 가능하다.

- `@JvmName` : 코틀린 선언이 만든 자바 필드나 메서드 이름 변경
- `@JvmStatic` : 메서드, 객체 선언, 동반 객체에 적용 시 자바 정적 메서드로 노출
- `@JvmOverloads` : 컴파일러가 자동으로 디폴트 파라미터 값이 있는 함수를 오버로딩
- `@JvmField` : 프로퍼티에 사용 시 public 자바 필드로 프로퍼티 노출

#### 10.1.3 어노티에션을 활용한 JSON 직렬화 제어
직렬화는 객체를 저장장치에 저장하거나 네트워크를 통해 전송하기 위해 텍스트나 이진 형식으로 변환하는 것이며, 역직렬화는 직렬화의 반대이다.

- 역직렬화 시 JSON에는 객체의 타입이 저장되지 않기 때문에 타입 인자로 클래스 명시
- 원시 타입, 객체 클래스, 컬렉션 타입의 프로퍼티 등도 포함될 수 있음

```kotlin
data class Person (
  @JsonName("alias") val firstName: String,
  @JsonExclude val age: Int? = null
)
```

위와 같이 어노테이션을 사용하여 직렬화 동작을 변경 가능하다.

- `@JsonName` : 프로퍼티의 이름을 직렬화 시 변경
- `@JsonExclude` : 해당 프로퍼티를 직렬화 시 제외
- 직렬화 대상에서 제외되는 프로퍼티는 반드시 디폴트 값을 지정

#### 10.1.4 어노테이션 선언
- kotlin : `annotation class`로 어노테이션 선언
- java : `@interface`을 이용하여 어노테이션 선언

```kotlin
annotation class JsonExclude
```

- 어노테이션 클래스는 선언 또는 식과 관련된 메타데이터의 구조를 정의
- 컴파일러에서 본문을 정의하지 못하게 막음
- 파라미터가 있는 어노테이션 클래스 선언 시 주 생성자에 선언하며 모든 파라미터는 `val`로 선언

```kotlin
annotation class JsonExclude(val name: String)
```

```java
public @interface JsonName {
  String value();
}
```

- 자바는 value 메서드를 제외한 모든 속성에 이름을 명시
- 코틀린은 이름을 붙이거나, 생략 가능

```kotlin
@JSonName(name = "test")
or
@JSonName("test")
```
자바에서 선언한 어노테이션을 코틀린에서 사용할 때 value를 제외한 모든 인자에 대해 이름을 붙여야한다.

#### 10.1.5 메타어노테이션 : 어노테이션을 처리하는 방법 제어
어노테이션 클래스에 적용할 수 있는 어노테이션을 **메타어노테이션**이라고 부르며, 표준 라이브러리에 있는 메타어노테이션은 컴파일러가 처리하는 방법을 제어한다.

```kotlin
// 적용할 수 있는 요소의 유형 지정
@Target(AnnotationTarget.PROPERTY)
annotation class JSonExclude
```
- 어노테이션이 붙을 수 있는 대상이 정의된 enum은 AnnotationTarget
- `@Target`은 필요 시 둘 이상의 대상을 한꺼번에 선언 가능
- 직접 만들 경우 `ANNOTATION_CALL`를 대상으로 지정

```kotlin
@Target(AnnotationTarget.ANNOTATION_CLASS)
annotation class BindingAnnotation
@BindingAnnotation
annotation class MyBinding
```

- 대상이 `PROPERTY`인 어노테이션은 자바에서 사용 불가
- `FIELD`를 사용하여 코틀린 프로퍼티와 자바 필드에 적용

**@Retension**
자바에서는 기본적으로 어노테이션을 `.class`에는 저장하지만 런타임에는 사용할 수 없게 한다.
하지만 대부분의 어노테이션을 런타임에 사용이 가능해야 하므로 코틀린에서는 @Retension 어노테이션을 `RUNTIME`으로 지정한다.

#### 10.1.6 어노테이션 파라미터 클래스 사용
정적인 데이터를 인자로 하는 것이 아닌 어떤 클래스를 선언 메타데이터로 참조하는 등의 기능을 구현 할 때 클래스 참조를 파라미터로 하는 어노테이션 클래스를 선언할 수 있다.

```kotlin
interface Company {
  val name: String
}

data class CompanyImpl (override val name: String) : Company

data class Person(
  val name: String,
  @DeserializeInterface(CompanyImpl::class) val company: Company
)
```

- 역직렬화를 사용할 클래스를 지정하기 위해 어노테이션 인자로 클래스 참조를 전달
- 클래스를 가리킬 떄 일반적으로 클래스 이름 뒤에 `::class` 키워드 사용

클래스 참조를 인자로 받는 어노테이션을 정의하는 방법에 대해 알아보자.

```kotlin
annotation class DeserializeInterface (val targetClass: KClass<out Any>)
```

- `KClass`는 `java.lang.Class`와 같은 역할을 하는 코틀린 타입
- 클래스에 대한 참조를 저장 할 때 사용
- `CompanyImpl::class` -> `KClass<CompanyImpl>` 동일
- `KClass<out Any>`의 하위 타입으로 인자가 동작
- 공변성 법칙에 따라 `out`을 제외하면 `Any` 외 다른 타입을 인자로 전달 불가능

#### 10.1.7 어노테이션 파라미터로 제네릭 클래스 받기
어노테이션 파라미터로 제네릭 클래스를 전달받는 방법에 대해서 알아보자.

```kotlin
interface ValueSerializer<T> {
  fun toJsonValue (value: T) : Any?
  fun fromJsonValue (jsonValue: Any?) : T
}
```
`ValueSerializer<Date>`를 구현하는 클래스의 참조를 어노테이션에 전달하고 싶다고 가정하자.

```kotlin
// Date 타입을 처리하는 직렬화 클래스
object DateSerializer : ValueSerializer<Date> {
    private val dateFormat = SimpleDateFormat("dd-mm-yyyy")

    override fun toJsonValue(value: Date): Any? =
            dateFormat.format(value)

    override fun fromJsonValue(jsonValue: Any?): Date =
            dateFormat.parse(jsonValue as String)
}
```
`Date` 타입을 처리하는 직렬화 클래스의 참조를 어노테이션의 파라미터로 전달해보자.

```kotlin
data class Person(
        val name: String,
        @CustomSerializer(DateSerializer::class) val birthDate: Date
)
```

**@CustomSerializer 구현**
```kotlin
annotation class CustomSerializer (
        val serializerClass: KClass<out ValueSerializer<*>>
)
```

- `out`을 사용하여 공변성을 통해 `ValueSerializer`을 구현하는 클래스만 인자로 받음
- 어떤 타입이 들어올지 모르기 때문에 스타 프로젝션을 적용

클래스를 인자로 받는 경우 어노테이션 파라미터에 `KClass<out 허용 클래스명>`으로 사용하면 되고, 제네릭 클래스를 인자로 받는다면 스타 프로젝션을 추가한다.

---

### 10.2 리플렉션: 실행 시점에 코틀린 객체 내부 관찰
실행 시점에 객체의 프로퍼티와 메서드에 접근할 수 있게 해주는 방법이 리플렉션이다.

컴파일러는 구체적인 선언을 기반으로 메서드 또는 프로퍼티 이름을 사용하고, 실제로 가리키는 선언을 컴파일 시점에 찾아내 실제 존재함을 보장한다.
만약 타입과 관계없이 객체를 다루거나 객체가 제공하는 메서드, 프로퍼티 이름을 실행 시점에만 알 수 있다면 리플렉션을 사용한다.

- `java.lang.reflect` 패키지를 통해 제공하는 표준 리플렉션
  - 코틀린 클래스는 일반 자바 바이트코드로 컴파일되기 때문에 자바 리플렉션 API도 완벽히 지원
  - 즉, 리플렉션을 사용하는 자바 라이브러리와 코틀린이 완벽히 호환된다는 의미
- `kotlin.reflect` 패키지를 통해 제공하는 코틀린 리플렉션 API
  - 널이 될 수 있는 타입 등 코틀린의 고유한 개념에 대한 리플렉션 제공
  - 자바 리플렉션을 대안으로 사용해야하는 경우들이 발생

#### 10.2.1 코틀린 리플렉션 API: KClass, KCallable, KFunction, FProperty

|구분|역할|사용법|
|---|---|---|
|KClass|클래스의 메타데이터 제공. 클래스 이름, 생성자, 멤버 등을 탐색|`MyClass::class.simpleName`|
|KCallable|호출 가능한 모든 요소의 공통 상위 인터페이스. 함수와 프로퍼티를 포함|`kClass.members.first { it.name == "greet" }`|
|KFunction|함수에 특화된 인터페이스. 함수의 파라미터 정보, 반환 타입, 호출 기능 제공|`::greet.call("World")`|
|KProperty|프로퍼티에 특화된 인터페이스. 프로퍼티 이름, 값 읽기/쓰기 기능 제공|`MyClass::name.get(instance)`|

위 정보를 바탕으로 `KClass`부터 사용 방법에 대해 알아보자.

```kotlin
class Ch10Person(val name: String, val age: Int)

fun main(args: Array<String>) {
    val person = Ch10Person("Test", 2)
    // public val <T : Any> Class<T>.kotlin: KClass<T>
    val kClass = person.javaClass.kotlin

    // 클래스 이름
    println(kClass.simpleName)
    // 클래스 프로퍼티
    kClass.members.forEach { println(it.name) }
}

>> Ch10Person
>> age
>> name
>> equals
>> ....
```

- `memberProperties` 등 kotlin-reflect 라이브러리를 통해 확장 함수 사용이 가능
- `implementation "org.jetbrains.kotlin:kotlin-reflect:[버전]`을 build.gradle에 등록하지 않을 경우 에러 발생
- `members`는 `KCallable<*>` 타입의 컬렉션

`KCallable`은 함수와 프로퍼티를 아우르는 공통 상위 인터페이스이다.

```kotlin
interface KCallable<out R> {
  fun call(vararg args: Any?): R
}
```

`call()`을 사용해 함수 호출이 가능하다.
```kotlin
fun foo(x: Int) = println(x)
// KFunction 클래스의 인스턴스
>> val kFunction = ::foo
>> kFunction.call(42)

42
```

- 함수 참조가 가리키는 함수 호출 시 `KCallable.call` 호출
- `call()`에 전달된 인자 개수와 원래 함수의 파라미터 개수가 동일해야함
- `KFunction1` 인터페이스를 통해 `invoke`를 사용하여 정해진 개수의 인자만 받아들여 호출이 가능
- 인자와 반환 타입 모두 안다면 `invoke` 호출이 더 유용함

또는 `KProperty`의 `call()`을 호출할 수도 있다.

- `KProperty`의 `call()`은 프로퍼티의 게터를 호출
- 최상위 프로퍼티는 `KProperty0` 인터페이스의 인스턴스로 표현

```kotlin
var counter = 0

>> val kProperty = ::counter
>> kProperty.setter.call(21) // 21로 세팅
>> println(kProperty.get()) // 프로퍼티 값 호출

21
```

멤버 프로퍼티의 경우 `KProperty1` 인스턴스로 표현되며, 인자가 1개인 get 메서드가 들어있다.
멤버 프로퍼티는 어떤 객체에 속해 있기 때무에 값을 가져오려면 프로퍼티를 얻고자 하는 객체 인스턴스를 전달해야한다.

```kotlin
class Person (val name: String, val age: Int)

>> val person = Person("Test", 29)
>> val memberProperty = Person::age
>> println(memberProperty.get(person)) // 객체 인스턴스 전달
29
```

- `KProperty1`은 제네릭 클래스으로 `KProperty<Person, Int>`로 동작했음
- 첫 번째 타입 파라미터는 수신 객체 타입
- 두 번째 타입 파라미터는 프로퍼티 타입을 표현
- 최상위 수준 또는 클래스 안에 정의된 프로퍼티만 리플렉션 접근 가능

실행 시점에 소스코드 요소에 접근하기 위해 사용할 수 있는 인터페이스의 계층 구조는 아래와 같다.

```bash
- KAnnotatedElement
|- KClass
|- KCallable
|  |- KFunction
|  |  |- KFunction1
|  |  |- KFunction2
|  |  |- KFunction3
|  |  |- KProperty.Getter
|  |  |- KMutableProperty.Setter
|  |  |- ...
|  |- KProperty
|  |  |- KMutableProperty
|- KParameter
```

#### 10.2.2 리플렉션을 사용한 객체 직렬화 구현
