**데이터베이스란?**

```basic
체계적으로 데이터를 저장하고 관리할 수 있는 구조화된 데이터의 집합을 의미한다.
빠르고 효율적인 데이터 검색, 삽입, 수정, 삭제가 가능하도록 설계되어 있으며 DBMS를 통해 접근이 가능하다.
```

---
**RDBMS과 NoSQL 차이**

RDBMS(Relational DataBase Management System)
```basic
데이터베이스 시스템이 관계형 모델을 따르며, 데이터를 행과 열로 구성된 테이블로 저장한다. SQL을 사용하여 데이터를 관리한다.

ACID 원칙을 따르는 트랜잭션을 지원하며, 수직 확장(Scale-up)에 적합하여 서버의 성능을 업그레이드 해야한다.
```

NoSQL
```basic
다양한 데이터 모델을 사용하는 데이터베이스로, 비정형 데이터나 스키마가 유연한 데이터를 처리하는데 적합하다.
문서, 키-값, 그래프 등 다양한 형태의 저장 방식을 제공한다.

BASE 원칙을 따르는 트랜잭션을 지원하며, 수평 확장(Scale-out)에 적합하여 여러 서버에 데이터를 분산시켜 처리할 수 있다.
```

---
**스키마란?**

```basic
데이터베이스의 구조와 제약 조건을 정의하는 청사진이라 할 수 있는데 데이터가 어떻게 구성되어야 하고,
어떤 형태를 가져야 하는지를 명확히 설명하는 규칙과 구조를 포함한다.
구조는 테이블, 데이터 타입, 관계 등을 정의하고, null 제약 조건 등을 통해 무결성을 보장한다.

하나의 데이터 베이스 안에 여러 개의 스키마가 존재 할 수 있고,
각 스키마들은 네임 스페이스 제공, 조직화, 접근 제어 등을 각각 설정 및 제어 할 수 있다.
또한, 스키마를 통해 다중 애플리케이션 지원에 활용하거나 버전 관리를 할 수 있는 장점이 있다.
Database 내에서 생성하는 스키마는 논리적 분할을 제공하는 컨테이너로서 역할을 수행하고,
데이터베이스 객체를 그룹화하여 관리하기 위해 사용한다.
```

---
**정규화(Normalization)의 개념과 목적**

```basic
정규화는 데이터베이스 내에서 데이터 중복을 최소화하고, 무결성을 유지하며,
쿼리의 성능을 향상시키기 위해 데이터를 구조화하는 과정이다.

목적은 다음과 같다.
정규화는 데이터 중복을 방지하여 저장 공간을 절약하고 데이터 일관성을 유지할 수 있다.
데이터를 논리적으로 분할하고 테이블 간에 관계를 정의한다.
데이터 삽입, 수정, 삭제 시 성능을 최적화 할 수 있으며, 조회 시에는 쿼리의 복잡성이 증가하면
성능이 저하될 수 있기 때문에 비정규화를 고려해야한다.
```

---
**인덱스와 동작원리**

인덱스
```basic
추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블에 저장된 데이터의 검색 속도를 향상시키기 위한 자료구조이다.
```

동작방식
```basic
특정 컬럼에 대한 인덱스를 생성한다.
해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 물리적 주소와 함께 저장된다.
where 조건문을 사용하여 쿼리를 실행할 때 인덱스에 저장되어 있는 데이터의 물리적 주소로 이동해 데이터를 가져온다.
```

B-Tree
```basic
대표적 밸런스 트리 중 하나로 노드 삽입 및 삭제 시 특정 규칙에 맞게 재정렬되어 양쪽 자식 노드 수의 밸런스를 유지하는 트리이다.
모든 리프 노드가 같은 깊이에 위치하기 때문에 O(log n)의 시간 복잡도를 가진다.

일반적인 트리처럼 좌, 우측만 사용하지 않고 노드에 저장된 값 사이의 포인터를 통해 탐색한다.
루트 노드에서 시작하여 검색할 값을 노드들과 비교한다.
검색 값이 존재하지 않으면 키 범위에 연결된 자식 노드로 이동하여 동일한 과정을 반복하고,
리프 노드에 도달하면 결과를 반환한다.
```

---
**인덱스 장단점**

```basic
장점
- 테이블을 조회하는 속도와 그에 따른 성능 향상
- 전반적인 시스템의 부하를 감소

단점
- 인덱스 관리를 위한 DB의 추가적인 저장 공간이 필요
- 데이터 삽입, 수정, 삭제 시 인덱스도 함께 업데이트되어 작업 성능 저하
- 너무 많은 인덱스 사용 시 복잡성 증가와 쿼리 성능 저하
```

---
**JOIN 종류와 각 차이점**

```basic
JOIN은 두 개 이상의 테이블에서 데이터를 결합하여 조회할 때 사용하는 SQL 문법이다.
```

INNER JOIN
```basic
두 테이블에서 일치하는 데이터만 결합하여 조회하는 방식으로 데이터가 완전히 일치하는 경우에만 사용하는 것이 유용하다.
```

OUTER JOIN
```basic
LEFT, RIGHT, FULL JOIN으로 구분되며, 부분적인 일치와 모든 데이터 조회가 필요한 경우 사용한다.

LEFT : 왼쪽 테이블의 모든 데이터를 가져오고, 오른쪽 테이블에서 일치하는 데이터가 있을 경우 결합하고,
없는 경우 NULL로 채워진다.
RIGHT : LEFT의 반대로 동작
FULL : 양쪽 테이블의 모든 데이터를 가져오고 일치하면 결합, 아니면 NULL로 채워진다.
```

---
**트랜잭선이란?**

```baisc
하나의 작업 단위로 모든 작업이 완전히 처리되거나 아무 작업도 처리되지 않는 상태로 보장하는 것을 의미한다.
```

---
**ACID 특성**

```basic
원자성 : 모든 작업을 하나의 단위로 실행하여 하나의 작업이라도 실패하면 롤백하여 이전 상태로 복구
일관성 : 트랜잭션이 시작 전과 후에 데이터베이스는 일관된 상태여야한다.
격리성 : 여러 트랜잭션이 동시 실행될 때, 각 트랜잭션은 간섭받지 않아야한다.
내구성 : 트랜잭션이 완료된 후에는 그 결과가 영구적으로 DB에 반영되어야한다.
```

---
**데드락과 해결방법**

발생 조건
```basic
- 상호 배제 : 한번에 하나의 프로세스만 자원을 사용한다.
- 점유 대기 : 하나 이상의 자원을 점유한 상태에서 다른 프로세스가 점유한 자원을 기다리는 상태이다.
- 비선점 : 다른 프로세스에 할당된 자원은 뺐을 수 없다.
- 순환 대기 : 프로세스들이 순환 형태로 자원을 대기하고 있는 상황이다.
```

```basic
두 개의 트랜잭션이 각각 lock을 설정하고, unlock을 하지 않은 상태에서 서로의 lock이 걸린 데이터에 접근할 때,
서로 대기를 계속해 영원히 처리되지 않는 상황을 이야기한다.

예방은 각 트랜잭션이 실행되기 전에 필요한 모든 자원을 Lock하는 방법과 LOCK_TIMEOUT문을 통해
일정 시간이 지나면 쿼리를 취소하는 방법이 있다.
다만, 모든 데이터를 잠금하기 때문에 병행성이 떨어지고, 기본 교착 상태인 데이터가 있을 경우 그 데이터에 접근하는 쿼리만 취소한다.

회피는 시간 스탬프를 활용해 교착상태가 일어나지 않도록 회피하는 방법이다.
Wait-Die 방식은 먼저 들어온 트랜잭션이라면 대기하고, 나중에 들어온 트랜잭션이라면 포기하고 나중에 다시 요청하는 방식이다.
Wound-Wait 방식은 먼저 들어온 트랜잭션이라면 데이터를 선점하고, 나중에 들어온 트랜잭션이라면 대기하는 방식이다.

낙관적 병행 제어 기법은 트랜잭션 실행 동안에는 검사를 수행하지 않고, 커밋된 후에 데이터에 문제가 있을 경우 롤백하는 방법이다.

또는 서로 다른 트랜잭션이 수행하는 작업의 자원을 동일한 순서로 보장해주면 데드락을 해결 할 수 있다.
```

---
**Redis**

```basic
오픈 소스 인메모리 데이터 구조 저장소이며, 데이터를 메모리에 저장하여 매우 빠른 읽기 및 쓰기 성능을 제공한다.
데이터는 key-value 형태로 저장하며, 메모리에 저장되어 매우 빠른 속도로 데이터에 접근 할 수 있다.
또한 주기적으로 디스크에 저장하거나 스냅샷을 생성할 수도 있어서 데이터 영속성을 지원한다.
Redis는 문자열, 리스트, 해시, 셋, 정렬된 셋 등 다양한 데이터 구조를 지원한다.

Redis는 주로 데이터베이스 조회를 캐싱하거나 사용자 세션 정보를 관리하고,
리스트 데이터 구조를 이용해 메세지 큐를 구현하는 등의 목적으로 사용한다.
다만, 메모리에 데이터를 저장하는 특성으로 데이터가 많아질수록 메모리 사용량이 증가하고,
복잡한 SQL 쿼리를 지원하지 않으므로 복잡한 쿼리 기능을 요구하는 상황에 적합하지 않을 수 있다.
```

---
**ORM이란?**

```basic
객체와 관계형 데이터베이스를 매핑하는 것을 의미한다.
객체와 테이블을 매핑하여 객체 중심의 개발이 가능하도록 보조하는 역할을 한다.

ORM은 복잡한 SQL 쿼리 대신, 객체를 통해 데이터베이스 작업을 수행할 수 있다.
코드의 유지보수성이 올라가며, 데이터베이스 독립성을 높이는데 도움을 준다.

다만, ORM 사용 시 성능 최적화를 위해 복잡한 쿼리나 대량의 데이터 처리는 네이티브 SQL을 사용하는 것이 적합하다.
```

---
**JPA에서 Entity란**

```basic
JPA에서 데이터베이스 테이블과 매핑되는 자바 클래스를 의미한다.
Entity 객체를 통해 테이블에 접근하여 작업을 수행할 수 있다.

JPA는 Entity를 생성할 때 기본 생성자를 사용하기 때문에 기본 생성자를 정의해야하며,
직렬화를 가능하게 하기 위해 Serializable 인터페이스를 구현한다.
```

---
**데이터 무결성과 보장 방법**

```basic
데이터베이스 내 데이터가 정확하고 일관된 상태를 유지하는 것을 말한다.

무결성 보장 방법은 다음과 같다.
개체 무결성 : 기본 키를 통해 각 행이 고유하게 식별되도록 보장
참조 무결성 : 외래 키를 통해 테이블 간의 일관성을 유지하도록 보장
도메인 무결성 : 데이터 타입, 형식, 범위 등을 미리 정의하여 데이터 유효성을 보장
고유 무결성 : 중복된 값이 특정 열 및 열 조합에 저장되지 않도록 보장
NULL 제약 조건 : NULL 값을 허용하지 않도록 설정
트랜잭션 사용 : 트랜잭션으로 묶어 처리하여 일관성을 보장
```

---
**샤딩이란?**

```basic
데이터베이스의 부하를 분산하기 위해 데이터를 여러 개의 데이터베이스 인스턴스로
수평적 확장(Scale-out)하여 저장하는 방법을 말한다.

샤딩은 데이터베이스 서버를 쉽게 추가하여 확장성을 높일 수 있고, 데이터가 여러 샤드로 분산되기 때문에
각 쿼리의 처리 속도가 빨라진다는 장점이 있다.

하지만, 데이터가 여러 샤드에 분산되어 데이터베이스의 설계와 관리가 복잡해 질 수 있고,
샤드 간에 Join 작업이 어려울 수 있다. 또한, 샤드를 재분할 하는 경우가 발생할 수 있고,
수평적 확장으로 인해 물리적인 PC 구매 및 서버 구성에 대한 비용이 증가할 수 있다.

샤딩의 전략은 다음과 같다.
범위 기반 샤딩 : 데이터의 범위를 기준으로 샤드에 데이터를 분할
해시 기반 샤딩 : 데이터를 해시 함수를 사용하여 고르게 분배
지리적 샤딩 : 데이터를 지리적 위치를 기준으로 분할하는 방식
```

---
**ERD**

```basic
데이터베이스 설계에서 테이블 간의 관계를 시각적으로 표현한 다이어그램이다.
데이터베이스의 구조를 명확하게 이해하는데 도움을 준다.

데이터베이스 설계의 기본적인 도구로 사용되고, 테이블 간의 관계와 구조를 정의하는데 도움이 된다.
엔티티, 속성, 관계로 구성되며, 관계의 유형은 1:1, 1:N, N:M이다.
```

---
**SQL Injection과 방지방법**

```basic
공격자가 악의적인 SQL 쿼리를 웹 애플리케이션의 입력 값으로 삽입하여 데이터베이스를 조작하는 공격 방법이다.

애플리케이션의 입력 검증 미흡 또는 쿼리 파라미터의 적절한 처리가 이루어지지 않을 때 발생하는 경우가 많다.

SpringBoot를 사용할 때 SQL Injection을 방어하는 방법은 다음과 같다.
- 파라미터 바인딩 사용을 통해 SQL 구문과 파라미터를 분리하여 입력 값을 SQL 구문으로 해석되지 않도록 한다.
ORM 기술을 이용하면 기본적으로 파라미터 바인딩을 사용한다.
- @Validation을 사용한 입력 값에 대한 검증을 수행하여 유효성을 검사한다.
- JWT 토큰 등을 이용하여 인증 및 권한을 부여받은 사용자만 요청을 허용한다.
```

---
**GROUP BY와 HAVING**

GROUP BY
```basic
테이블의 데이터를 특정 열 기준으로 그룹화할 때 사용하며 그룹화된 각 그룹에 대해 집계 함수를 적용할 수 있다.
```

HAVING
```basic
GROUP BY로 그룹화된 데이터에 조건을 걸 때 사용되는 구문이다.
WHERE과 비슷하지만, WHERE은 개별 해에 조건을 걸 때 사용하고 HAVING은 그룹화된 결과에 조건을 걸 때 사용한다.

WHERE은 기본적으로 데이터를 그룹화하기 전에 행 단위로 조건을 적용하기 때문에 조건 대상의 범위가 HAVING에 비해 넓다.
가급적이면 WHERE을 먼저 사용하여 데이터를 필터링하고 GROUP BY로 처리할 데이터의 양을 줄이면 성능이 향상될 수 있다.
```

---
**Table Scan**

```basic
테이블의 스캔의 구성은 다음과 같다.

- Sequential Scan : 테이블의 모든 데이터를 하나씩 확인하는 방법으로 인덱스가 없는 컬럼 검색 시 사용한다.
- Index Scan : 인덱스를 탐색하는 방식으로 동작한다. 가장 실행시간이 짧다.
- Index Only Scan : 인덱스에 필요한 데이터가 있는 경우 사용되는 방식이다.
- Bitmap Scan : Sequential Scan + Index Scan 조합 방식으로, Index Scan에서 발생할 수 있는 과도한 랜덤 I/O를 방지하면서 어느정도 성능을 보장한다.
```

---
**트랜잭션 격리수준**

Read Uncommitted
```basic
트랜잭션의 커밋이 반영되지 않은 내용도 읽을 수 있는 격리수준

발생가능한 문제 - Dirty Read, Non Repeatable Read, Phantom Read
```

Read Committed : Postgresql Default
```basic
트랜잭션 커밋이 반영된 내용만 읽을 수 있는 격리수준

발생가능한 문제 - Non Repeatable Read, Phantom Read
```

Repeatable Read : MySQL Default
```basic
트랜잭션이 수행되는 범위 데이터에 대한 수정/삭제가 불가능하게하여 조회 시
항상 동일한 데이터 응답을 보장하는 격리수준

발생가능한 문제 - Phantom Read
```

Serializeble
```basic
트랜잭션이 수행중인 범위에 대하여 아무런 작업도 수행하지 못하는 격리수준

발생가능한 문제 - 없음
```
---

**레디스 센티널과 클러스터 모드**
```basic
Sentinel 대신 클러스터 모드를 자주 사용하는 이유는 자동 장애 복구뿐만 아니라
데이터 샤딩(분산 저장)까지 제공하기 때문이다.

즉, Sentinel은 장애 복구에만 집중된 반면, 클러스터는 확장성과 내구성을 함께 제공하기 때문에
대규모 트래픽과 데이터량이 있는 서비스에 더 적합하다.

센티널은 자동 샤딩이 지원되지 않는 반면 클러스터 모드는 자동 샤딩이 지원되고, 키 공간 분산을 통해 이루어진다.
이런 이유로 레디스의 Master-slave 구조에서 master가 죽으면 자동으로 slave를 승격시킨다.

클라이언트는 센티널로부터 새 master 정보를 받아 재접속하지만 샤딩은 직접 구현해야한다.
즉, 센티널은 고가용성만 해결하고 수평 확장은 불가능하다. 그에 반해 클러스터 모드는 노드 간 키 공간을 분할해서 자동 샤딩한다.

각 노드는 일부 키만 보유하여 메모리 분산이 가능하기 때문에 마스터-슬레이브 구조를 유지하고, 장애 시 자동으로 페일오버를 지원한다.
즉, 고가용성과 수평 확장 모두 제공하는 구조이기 때문에 클러스터 모드를 자주 사용한다.

다만, 클러스터 모드도 단점이 존재하는데 클라이언트가 슬롯 이동을 따라가야 하기 때문에 클러스터-aware 클라이언트가 필요하고,
전체 키 조회를 통해 multi-key 트랜잭션이 동일 슬롯 범위 내에서만 가능하며, 운영이 복잡하다.
```
---

**수평, 수직 샤딩**
```basic
수평 샤딩 : 데이터를 행 기준으로 나누어 여러 서버에 분산
수직 샤딩 : 컬럼이나 기능/도메인 기준으로 나누는 것

수평 샤딩은 같은 테이블 스키마를 유지하지만 데이터의 범위만 분리하는 것으로 데이터 양과 요청 부하를 분산할 수 있고, 스케일 아웃이 가능하다.
하지만 크로스 조인 및 그룹바이 등의 복잡한 연산에서 제한이 발생하고, Shard key 설계 실패 시 불균형 발생이 일어날 수 있다.

수직 샤딩은 각 샤드에 서로 다른 테이블 구조가 존재하며, 기본 정보와 민감 정보를 분리하는 등의 작업이 가능하다.
기능 단위로 책임을 분리하기 때문에 서비스 경계에 맞게 확장 및 배포가 가능하고, 특정 데이터만 조회 시 I/O가 줄어든다.
하지만 테이블 간 조인이 불가능하고, 데이터 중복 또는 정합성 관리가 어렵다.

수평 샤딩은 사용자 수가 많은 SNS, 쇼핑몰의 사용자, 주소, 주문 등의 테이블에 사용되고,
수직 샤딩은 마이크로서비스 기반 시스템에서 서비스별 DB를 분리하는 경우 사용한다.

가장 많이 사용되는 방식은 하이브리드 방식으로 기능은 수직 샤딩으로 테이블은 수평 샤딩으로 분리하는 방식이다.
```
