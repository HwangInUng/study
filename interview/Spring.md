**Spring이란?**

자바 기반의 엔터프라이즈 애플리케이션을 구축하는데 사용되는 프레임워크

주요 장점
- 경량성
	- 필요한 객체만 생성하고, 관리 -> 자원 낭비 최소화
	- 간단한 설정과 독립적인 실행 환경 제공
- 제어의 역전(IoC) : 객체의 생명주기를 개발자가 제어하는 것이 아닌 스프링 컨테이너에서 생성하고 관리하며, 의존성 주입을 통해 이루어짐
- 관점지향 프로그래밍(AOP) : 로깅, 인증 및 인가 등 횡단적 관심사를 분리하기 위한 AOP 지원
- 다양한 기술을 통합하여 사용할 수 있는 환경을 제공

---
**IoC와 DI**
- IoC(제어의 역전) : 객체의 생성 및 관리를 애플리케이션 코드로 작성하는 것이 아닌 컨테이너나 프레임워크가 담당하게 하는 디자인 원칙
- DI(Dependency Injection) : 객체의 의존성을 외부에서 주입하는 방식으로 IoC를 구현하는 구체적인 방법 중 하나
	- 생성자 주입 : 객체가 생성될 때 필수적인 의존성을 주입해야하는 경우
	- 세터 주입 : 의존성이 선택적일 때 또는 객체 생성 후에 의존성 설정이 필요한 경우
	- 필드 주입 : @Autowired 어노테이션을 사용하여 의존성을 주입하여 코드는 간결하지만 모킹으로 인한 테스트를 어렵게 만들 수있음
		- 필드 주입의 경우 private로 선언된 필드에 대한 의존성 주입을 위해 리플렉션이 발생
	- 세 가지의 주입 방법 중 생성자 주입이 스프링의 모범 사례로 권장
		- 의존성의 명확성
		- 불변 객체 생성 유리
		- 테스트 용이성
		- 순환 참조 방지
		- 프레임워크에 종속적이지 않음

---
**@RequiredArgsConstructor**

Lombok에서 제공하는 어노테이션으로 필수 필드에 대해 생성자를 자동으로 생성해주는 기능으로 final 또는 @NonNull 어노테이션이 붙은 필드를 매개변수로 받는 생성자를 자동으로 생성해준다.
- 컴파일 시점에 생성자를 자동으로 생성 -> 최적화 달성
- 리플렉션을 사용하지 않고 일반적인 메서드 호출 방식으로 동작
- 개발자가 직접 생성자를 작성할 필요가 없음

@Autowired는 의존성 주입을 명시적으로 지정할 때 사용하고, @RequiredArgsConstructorsms 생성자를 자동으로 생성하는 역할을 한다.

--- 
**왜 Bean을 사용하는가?**

- Spring IoC 컨테이너는 객체의 생성, 초기화, 설정, 소멸 등 효율적으로 관리
- 이를 통해 중복된 코드를 줄이고, 싱글톤 빈으로 설정된 객체는 하나의 인스턴스만 생성되기 때문에 메모리 사용량을 줄일 수 있다.
- 의존성 주입을 통해 테스트 가능성을 높이고 객체 간의 결합도를 낮출 수 있다.
- AOP 적용이 쉽다. 프록시 객체 생성 대상에서 일반 객체는 제외 된다.

---
**Spring AOP**

핵심 비즈니스 로직에 횡단 관심사를 분리하여 모듈화하는 프로그래밍 기법

- 런타임 시 프록시 객체를 사용하여 횡단 관심사를 처리하는 방식
- Spring AOP는 IoC 컨테이너에 의해 관리되는 Spring Bean에만 AOP를 적용하도록 설계
- Spring 컨테이너의 라이프사이클과 설정에 의존
- Spring IoC에 의해 관리되는 빈의 프록시 객체를 생성하고 메서드 호출을 가로채고, 부가 기능을 적용

주요 구분
- Aspect : 흩어진 관심사를 모듈화 한 것으로 부가 기능을 모듈화
- Target : Aspect를 실제로 적용하는 대상(메서드 등)
- Advice : 실질적으로 기능을 수행하는 구현체
- Join Point : Advice가 적용되는 위치와 해당 지점
- Point Cut : Join Point의 상세 내역을 정의한 것

실행 시점
- @Before : 타켓 메서드 호출 전
- @After : 타켓 메서드 수행 후
- @AfterReturning : 정상적 반환 후
- @AfterThrowing : 예외 발생 후
- @Around : 실행 전 후

동작 방식
- 스프링 시작 시 프록시 생성기가 모든 @Aspect 빈 조회
- @Aspect 어드바이저 빌더를 통해 @Aspect 기반 어드바이저들을 생성 및 저장
- 스프링 빈으로 객체가 등록될 때, 어드바이저들을 조회
- 매칭되는 경우 프록시 객체를 스프링 컨테이너에 등록
- 객체 사용 시 프록시 객체가 메서드 호출 등 로직을 수행한 후 실제 객체를 호출
- 실제 객체의 비즈니스 로직 수행

---
**Spring Bean의 생명주기**
- 스프링 컨테이너 생성: IoC 컨테이너가 생성되고 초기화됩니다.
- 스프링 빈 생성: 빈 정의를 기반으로 빈이 인스턴스화됩니다.
- **의존 관계 주입**: 빈에 필요한 의존성이 주입됩니다.
	- 생성자 주입: 빈 생성과 의존성 주입이 동시에 발생.
	- 세터/필드 주입: 빈이 생성된 후에 의존성 주입이 이루어짐.
- 초기화 콜백 메서드 호출: 빈이 준비된 후 초기화 작업이 수행됩니다.
- 스프링 빈 사용: 빈이 사용되어 비즈니스 로직을 수행합니다.
- 소멸 전 콜백 메서드 호출: 빈이 소멸되기 전에 종료 작업이 수행됩니다.
- 스프링 컨테이너 종료: 컨테이너가 종료되면서 빈이 소멸됩니다.

---
**@RequestBody, @RequestParam, @ModelAttribute**

**@RequestBody** 는 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 MessageConverter를 통해 Java Object로 변환시켜주는 역할을 합니다.

**@RequestParam** 은 필수 여부가 true이기 때문에, 기본적으로 반드시 해당 파라미터가 전송되어야 합니다. 전송되지 않으면 400 Error를 유발할 수 있으며, 반드시 필요한 변수가 아니라면 required의 값을 false로 설정해줘야 합니다.

**@ModelAttribute** 는 HTTP Body 내용과 HTTP 요청 파라미터의 값들을 생성자,Getter,Setter를 통해 1대 1로 객체에 바인딩시킨다. 만약 값을 주입해주는 생성자나 Setter함수가 없다면 매핑을 시키지 못하고, null을 갖게 된다.
- 각각의 **필드 단위로 적용**되어 특정 필드에 타입이 맞지 않는 오류가 발생해도 나머지 필드는 정상 처리할 수 있고 **Validator**를 사용한 검증도 적용할 수 있습니다.

- 사용 예) @ModelAttribute Item item 다음에 BindingResult bindingResult 위치 시킵니다.

---
**Servlet**

HTTP 요청 정보를 쉽게 사용하고, 응답 정보를 쉽게 반환할 수 있으며 개발자들이 집중해야하는 처리 로직에 집중이 가능하다.

---
**Spring의 주요 모듈**

- Spring Core : Spring Framework 중심에 있는 모듈, IoC와 DI 제공을 통해 객체 간의 느슨한 결합 지원
	- 코어를 확장한 모듈로 Spring Context가 있음
	- BeanFactory : 생성할 빈에 대한 정보 및 객체를 보유한 컨테이너
	- ApplicationContext : BeanFactory의 모든 기능을 포함하며, 애플리케이션의 전반적 설정 정보를 보유한 컨테이너
- Spring AOP : 관점 지향 프로그래밍을 지원
- Spring Web : 서블릿 API와 통합되며, Spring MVC 패턴을 기반으로 한 웹 애플리케이션 개발 지원
	- Spring MVC : MVC 디자인 패턴을 구현한 모듈로 사용자 요청에 대한 적절한 응답을 반환한다.
	- Spring WebSocket : 실시간 양방향 통신을 가능하게 해주는 기능 지원
	- Rest Support : RESTful 서비스 지원, @RestController 등
	- Spring WebFlux : 비동기 및 논블로킹 방식의 웹 애플리케이션을 개발하도록 지원
- Spring DAO : Spring Framework의 전통적인 데이터 접근 계층으로 데이터베이스와의 상호작용을 단순화하고, 예외 처리를 효율적으로 관리
	- 확장한 모듈로 Spring Data가 있음

---
**@Autowired와 @Qualifier 차이**

- Autowired : 스프링에서 DI를 자동으로 처리해주는 어노테이션
- Qualifier : @Autowired와 함께 사용되어 자동 주입 시 모호성을 해결하는데 사용하는 어노테이션

결론적으로 DI를 처리하기 위해서는 @Autowired를 사용해야하고, 이 과정에서 자동 주입이 모호한 상황을 해결하기 위해 빈의 이름을 명시적으로 지정하여 도움을 주는 역할을 하는 것이 @Qualifier이다.

---
**@Component, @Repository, @Service, @Controller 차이**

- @Component : 특정 목적이 없는 일반적인 빈을 등록할 때 사용하기 위한 어노테이션으로 빈 등록에 기본이 되는 어노테이션
- @Repository : 데이터 접근 계층(DAO)에서 사용하는 어노테이션이고, 데이터 액세스 관련 예외를 스프링의 데이터 액세스 예외로 변환
- @Service : 비즈니스 로직을 수행하는 서비스 계층에서 사용하는 어노테이션이고, 트랜잭션 처리를 관리
- @Controller : 웹 요청을 처리하는 컨트롤러 클래스에 사용하는 어노테이션이고, 웹 계층에서 사용

---
**Bean Scope 종류**

- Singleton : Spring 컨테이너에 하나의 인스턴스만 생성되는 스코프로 메모리 사용 효율이 높고, 빈의 인스턴스 관리가 용이
- Prototype : 매번 새로운 인스턴스를 생성하고 의존성 주입 이후로는 스프링 컨테이너가 관리하지 않아 수명 주기를 직접 관리해야 할 수도 있음
- Request : HTTP 요청당 하나의 빈 인스턴스를 생성하고, 요청이 완료되면 소멸
- Session : HTTP 세션당 하나의 빈 인스턴스를 생성하고, 세션 종료 시 소멸

---
**SpringBoot와 Spring Framework의 차이**

SpringBoot는 SpringFramework를 기반으로 더 간편한 설정과 빠른 개발을 지원하는 확장된 프로젝트이며, 차이점은 다음과 같다.

- XML 파일이나 Java 기반 설정을 수동으로 하지 않고, Autoconfiguration 기능을 제공하여 처리하며, @SpringBootApplication 어노테이션 하나로 프로젝트에 대한 간편 설정이 가능
- Srping Boot Starter 의존성을 제공하여 공통적인 기능에 필요한 의존성을 자동으로 설정
- 내장형 웹 서버가 제공되어 애플리케이션을 JAR 파일로 패키징하고 독립적으로 실행이 가능하도록 지원

---
**SpringBoot의 장점과 주요기능**

자동 설정
애플리케이션의 클래스 패스를 검사하고, 발견된 라이브러리와 클래스에 따라 자동으로 환경을 설정하는 기능을 제공한다. spring-boot-starter-web 의존성을 추가하면 내장 WAS와 Spring MVC를 자동으로 구성한다.

내장 서버
내장된 WAS를 통해 독립 실행형 JAR 파일로 실행 할 수 있기 때문에 별도의 WAS 설치가 필요하지 않아 배포의 간소화를 달성 할 수 있다.

외부 설정
.properties 또는 .yaml 파일을 통해 애플리케이션의 설정을 외부에서 관리가 가능하다.

---
**@SpringBootApplication 어노테이션의 역할**

@SpringBootConfiguration, @EnableAutoConfiguration, @ComponentSacn 3개의 핵심 어노테이션을 조합한 형태로 애플리케이션 시작 시 간편 설정을 지원하는 역할을 합니다.

먼저 @ComponentScan을 통해 설정된 패키지 범위 내에서 빈을 스캔하고, IoC 컨테이너에 빈들을 구성하고, @EnableAutoConfiguration을 통해 클래스 패스에 있는 의존성을 기반으로 자동 설정을 수행하는데 이 때 starter-web 의존성이 존재하면 내장 WAS가 자동 설정되어 웹 애플리케이션 환경이 구성됩니다.

또한, spring-boot-autoconfiguration 모듈에 있는 META-INF/spring.factories 파일에 정의된 설정 클래스들을 로드하고 의존성을 구성하여 애플리케이션 실행에 대한 간편 설정을 지원합니다.

추가로 .factories 파일은 Springboot 3.x 버전부터 .AutoConfiguration.imports 파일로 변경되었습니다.

---
**SpringBoot의 내장형 서버**

애플리케이션이 별도의 WAS 설치 및 설정 없이 독립적으로 실행될 수 있도록 지원하는 기능이다.

종류는 Tomcat, Jetty, Undertow 3가지가 있으며 기본 설정은 Tomcat으로 되어있다.
Tomcat은 서블릿 컨테이너 역할을 수행하며, 동기 방식의 요청 처리를 지원하고, Jetty는 더 가벼운 서블릿 컨테이너로서 고성능이 요구되는 애플리케이션 또는 더 작은 메모리 공간이 필요한 환경에서 주로 사용된다.

마지막으로 Undertow는 논블로킹 방식에서 지원하는 가벼운 서버로, Spring WebFlux에 적합하게 사용되며, 비동기 요청 처리에 강점을 가지고 있다.

---
**Spring Data JPA**

객체지향 프로그래밍과 관계형 데이터베이스 간의 패러다임 불일치를 해결하기 위해 설계된 ORM 기술을 지원하는 Srping Data 프로젝트의 하위 모듈이다.

- ORM 지원 : 객체와 관계형 데이터베이스 간의 데이터 변환을 자동화하며, 데이터베이스의 쿼리를 자바 메서드로 변환하는 작업을 간편하게 처리한다.
- Hibernate 통합 : 자바 진영의 ORM 기술에 대한 인터페이스를 제공하고, Hibernate는 해당 인터페이스를 구현한다.
- Repository 패턴을 사용해서 데이터베이스 작업을 단순화한다. 기본적인 CRUD 작업을 인터페이스만 정의하면 스프링이 자동으로 구현체를 제공한다.
- JPQL, Native 쿼리 등을 지원하여 복잡한 쿼리에 대한 처리를 지원한다.

---
**JPA와 Hibernate 차이**

JPA는 자바 진영의 ORM 표준 인터페이스이며, Hibernate는 JPA의 표준을 구현한 프레임워크다.
다만 Hibernate는 JAP에서 제공하지 않는 고유 기능을 포함한다.
- 1차 및 2차 캐싱 : 같은 세션 내에 동일한 엔터티에 대한 중복 조회 방지 및 데이터베이스 조회 횟수를 감소시켜 성능 향상 달성
- 원시 SQL 지원 : 복잡한 쿼리가 필요하거나 데이터베이스 종속적인 기능을 사용할 때 네이티브 쿼리를 미리 정의할 수 있다.

---
**Spring의 트랜잭션 관리**

트랜잭선은 데이터베이스의 일련의 작업이 성공하거나 모두 실패해야 하는 논리적 작업 단위이다. 트랜잭선은 ACID란 특성을 갖는다.
- Atomicity (원자성): 트랜잭션의 작업이 모두 성공하거나 모두 실패해야 해.
- Consistency (일관성): 트랜잭션이 완료된 후에 데이터베이스는 일관된 상태를 유지해야 해.
- Isolation (고립성): 동시에 수행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 해야 해.
- Durability (지속성): 트랜잭션이 완료되면, 그 결과는 영구적으로 반영돼야 해.

관리 방식
- 선언적 트랜잭션 관리
	- 어노테이션 기반으로 선언하는 방식
	- 코드가 간결하고 유지보수가 쉬우며 비즈니스 로직과 분리되는 장점이 있다.
- 프로그래밍 방식의 트랜잭션 관리
	- 코드 내에서 명시적으로 제어하는 방식
	- 더 세부적인 트랜잭션 제어가 가능

---
**@Transaction 어노테이션**

Spring이 자동으로 트랜잭션을 시작하고, 작업이 끝난 후 커밋 또는 롤백을 처리하는 기능을 지원하는 어노테이션이다.

@Transaction은 클래스 또는 메서드에 지정할 수 있다. 클래스로 지정하는 경우 클래스의 모든 메서드에 트랜잭션이 적용된다.

@Transaction은 프록시 객체를 통해 트랜잭션을 관리하는데 프록시 객체는 외부에서 호출된 메서드에 대해서만 트랜잭션을 적용할 수 있다. 이런 이류로 같은 클래스 내의 메서드 간의 호출은 프록시가 개입할 기회가 없어 정상적인 트랜잭션 처리가 적용되지 않는다.

이런 경우에 해결 방법은 메서드를 다른 클래스로 분리하거나 ApplicationContext 객체를 호출하고, getBean()을 통해 해당 클래스를 호출하여 메서드를 실행하면된다.

주요 속성
- propagation : 트랜잭션 전파 속성을 정의
	- REQUIRED(기본) : 현재 트랜잭션이 있으면 그대로 사용, 없으면 생성
	- REQUIRED_NEW : 항상 새로운 트랜잭션 생성, 기존은 일시 정지
	- NESTED : 중첩된 트랜잭션 생성, 내부적으로 중첩될 경우가 예상되면 사용
	- MANDATORY : 반드시 기존 트랜잭션이 존재해야하고, 없을 경우 예외 발생
	- SUPPORTS : 트랜잭선이 있으면 트랜잭션 내에서 실행, 없으면 트랜잭션 없이 실행
	- NOT_SUPPORTED : 트랜잭션 없이 실행하고, 기존에 있는 트랜잭션은 일시 정지
	- NEVER : 이미 트랜잭션이 존재하면 예외 발생, 트랜잭선 없이 실행
- isolation : 트랜잭션 격리 수준 정의
	- DEFAULT : 데이터베이스의 기본 격리 수준 사용
	- READ_UNCOMMITTED : 다른 트랜잭션이 커밋하지 않은 데이터도 읽을 수 있다
	- READ_COMMITED : 다른 트랜잭션이 커밋한 데이터만 읽을 수 있다.
	- REPEATABLE_READ : 같은 트랜잭션 내에서 동일한 쿼리 결과를 보장한다.
	- SERIALIZABLE : 가장 높은 격리 수준으로, 트랜잭션을 직렬화하여 처리하고, 성능 저하 가능
- timeout : 지정된 시간 내에 완료되지 않으면 롤백
- readOnly : 읽기 전용 트랜잭션으로 명시하여 데이터 수정이 필요 없는 작업의 성능을 최적화
- rollbakcFor : 특정 예외에 대한 롤백여부 결정

---
**RestController와 Controller의 차이**

RestController
@Controller와 @ResponseBody가 합쳐진 형태의 어노테이션으로 API 요청에 따른 응답 본문을 반환하는 역할을 수행한다. Spring Web 모듈에 속하며 주로 REST API를 개발할 때 사용된다

또한, HttpMessageConverter를 통해 응답 본문이 직렬화되어 반환된다.

Controller
웹 요청에 대한 처리를 수행하는 클래스에 사용되는 어노테이션으로 View를 응답으로 반환하며 MVC 패턴에서 주로 사용된다.

또한, ViewResolver를 통해 HTML, JSP 등을 찾아서 View의 이름을 반환하면 해당 뷰를 렌더링한다.

---
**Spring MVC 아키텍처**

<img width="600" alt="SpringMVC 아키텍처" src="https://github.com/user-attachments/assets/2906e2ca-634b-4bec-9685-2778eab76fe8">


- DispatcherServlet : 클라이언트의 모든 요청을 받아들이는 프론트 컨트롤러 요청을 적절한 핸들러에게 전달
- HandlerMapping : 들어온 요청을 처리할 수 있는 핸들러를 결정
- HandlerAdapter : 핸들러를 실행할 때 실행 방법을 결정
- Controller : 요청을 접수하여 비즈니스 로직을 수행하고, 뷰 또는 데이터를 반환
- ViewResolver : 반환된 뷰 이름을 실제 뷰로 변환

---
**Spring에서 CORS 설정**

Spring에서 CORS 설정은 총 세 가지 방법으로 설정할 수 있다.

애플리케이션 전체에 적용하는 방법은 WebMvcConfigurer를 implements하고, addCorsMapping() 메서드를 오버라이딩하여 설정 할 수 있다.

- addMapping : 대상 경로를 설정
- allowedOrigins : 허용할 도메인
- allowedMethds : 허용할 HTTP 메서드 종류
- allowedHeaders : 허용할 헤더 설정
- allowCredentials : 인증 정보 허용 여부

Controller에서 직접 설정하는 방법은 @CrossOrigin 어노테이션에 허용할 도메인을 지정해주면된다.

마지막 방법은 SpringBoot에서 corsFilter를 정의하여 설정할 수 있다.
