**JVM 메모리구조**

<img width="600" alt="스크린샷 2024-11-16 오후 8 18 57" src="https://github.com/user-attachments/assets/334f5995-9903-4757-a719-9f4a012f0353">

Heap, Stack, Pc register, Method area 구분

Heap
- 객체, 배열과 같은 동적으로 생성되는 인스턴스가 위치하는 메모리 영역
- 공유 영역으로 모든 스레드가 접근 가능
- 가비지 컬렉션 대상
- young generation : eden(최초 할당), survivor(Minor GC 수행)
- old generation : 가득차면 Minor GC 수행
- metaspace

Stack
- 각 스레드마다 존재
- 지역, 매개 변수 및 리턴 주소 등이 저장되는 영역
- 스레드별로 독립되어 동기화 문제가 발생하지 않음
- 메모리 접근이 빠르다

Program Count Register 
- 현재 실행중인 스레드가 다음에 실행할 명령의 주소를 카리키게함
- 스레드별로 독립적

Method area
- 클래스에 대한 메타데이터 저장 영역
- 상수, static 변수, 메서드 코드 등
- 모든 스레드 공유
- JVM 클래스 로드 시 해당 정보가 저장되는 영역

---
**Collection**

데이터 구조와 알고리즘을 표준화된 방식으로 제공하여 효율적으로 데이터 저장 및 조작하기 위한 클래스와 인터페이스의 집합

구성
- Iterable > Collection > List, Set, Queue
- Map

구분
 - List : 순서를 보장하며 요소의 중복을 허용한다. 또한 인덱스를 사용하여 요소에 접근 가능
	 - ArrayList
		 - O(n)의 시간 복잡도
		 - 인덱스를 통한 요소를 읽는 속도가 빠름
		 - 요소 간 빈공간을 허용하지 않기 때문에 삽입/삭제 시 모든 요소의 위치가 이동하여 성능 저하가 발생 할 수 있음
		 - 단, 순차 삽입/삭제는 가장 빠른 성능을 보여줌
	 - LinkedList
		 - 자바는 이중 연결 리스트로 구현되어 있음
		 - 요소는 노드 객체를 연결하여 구성 -> 배열과는 다름
		 - 삽입/삭제가 빠르지만 읽기 성능이 상대적으로 느림
		 - pop, poll, peek, offer 등 큐와 관련된 메서드 지원
	 - Vector
		 - 동기화 지원으로 스레드에 안전을 보장
		 - 동기화로 인한 성능 저하 발생
		 - Collection API 이전부터 존재
	 - Stack
		 - Vector를 상속받아 후입선출 구조를 구현
		 - 성능이 좋지 못하기 때문에 ArrayDequeue를 사용하여 Stack의 역할을 대체하는게 효과적
 - Set : 중복을 허용하지 않고, 순서를 보장하지 않는 컬렉션으로 인덱스로 검색 할 수 있는 get메서드 없음
	 - HashSet
		 - 가장 빠른 임의 검색 속도
		 - 배열과 연결 노드를 결합한 자료 구조
		 - 요소의 순서를 보장하지 않음
	 - LinkedHashSet
		 - 요소의 삽입 순서를 유지한다
		 - 중복제거와 순서 유지 중요 시 사용
	 - TreeSet
		 - 이진 검색 트리(레드-블랙 트리)로 구현되어 있음
		 - 요소를 정렬하여 저장하기 때문에 정렬 작업에서 사용할 때 효과적
		 - NavigableSet 인터페이스를 구현 -> 범위 검색 및 정렬 지원
 - Queue : FIFO 구조를 구현한 컬렉션
	 - LinkedList
		 - List와 Queue 모두를 구현, 양쪽에서 삽입/삭제가 가능
	 - PriorityQueue
		 - 요소를 우선순위에 따라 정렬하여 저장
		 - Comparable 인터페이스 구현이 필수 -> compareTo() 메서드 로직으로 우선순위 결정
		 - 자바에서는 배열로 저장하여 힙의 특성을 유지
		 - 최소힙으로 기본 동작
 - Map : 키-값 형태의 자료로 저장하며, 키는 중복이 허용되지 않고, 값은 중복 허용
	 - HashMap
		 - 해시 테이블 기반 빠른 조회 제공
		 - 키와 값 null 허용
		 - 키 또는 값의 순서를 보장하지 않음
	 - LinkedHashMap
		 - 삽입 순서를 유지
		 - 접근 순서에 따라 정렬되도록 설정 가능
	 - TreeMap
		 - 이진 검색 트리로 구현
		 - 키를 정렬된 순서로 저장
		 - NavigableMap 인터페이스를 구현
	 - HashTable
		 - 동기화 지원으로 스레드 안전성 제공
		 - 해시 함수를 통해 해싱한 결과를 배열의 인덱스로 사용
		 - 성능 저하 유발
	 - ConcurrentHashMap
		 - 스레드 안전성을 제공하는 Map 구현체

**Concurrent Collection**

Java 5부터 스레드 안정성을 확보한 컬렉션을 제공하며, 단일 스레드 환경에서는 사용 시 성능에 불리

---
**HashMap 동작방식**
- 키의 해시를 기반으로 인덱스 계산 후 버킷에 Entry 저장하는 방식으로 동작한다.
- 해시 충돌 발생하면 동일한 인덱스에 복수 개의 Entry 객체를 저장하는데 다음과 같다.
	- 6개 이하는 연결리스트
	- 8개 이상은 트리로 자료구조 변경
	- 트리 구조로 변경될 때는 **레드-블랙 트리**로 변환되어 검색 및 삽입 성능이 O(log n)으로 향상
- 자료구조를 변경시키는데 2가 차이나는 이유
	- 키 값이 반복적으로 삽입/삭제되는 경우 불필요한 자료 구조 변환 작업을 막기 위해 2의 간격을 둠
- 해시 충돌을 줄이기 위해 비트 연산을 통해 해시 코드를 변형하는 보조 해시 함수를 사용
- 해시 코드가 같은 경우 equals() 메서드를 통해 실제 키 값 확인
- hashCode()가 같고, equals()가 true이면 동일한 객체로 간주

**HashMap 버킷** 
- 로드 팩터 - 리사이징 수행 결정의 임계값으로 기본 0.75로 설정
- 높이면 메모리 사용량 증가, 성능 증가 / 줄이면 해시 충돌 증가 성능 저하
- 리사이징 수행 - 해시 테이블 크기가 2배 증가
- 새로운 해시 테이블로 재배치 - 해시 코드 재계산, 모든 Entry 새 버킷에 배치
- 데이터의 크키가 예상된다면 초기 용량 명시 권장

---
**equals()와 hashCode()**

- 객체의 동등성 비교를 위해 사용하는 메서드
- equals : 객체의 값 자체를 비교하는데 사용
	- Object 클래스에서 제공할 때에는 참조값을 비교
	- 실제 값을 비교하고 싶은 경우 오버라이드 필요
- hashCode : 객체의 해시 코드 생성 시 사용
	- Object 클래스에서 제공할 때에는 객체의 참조값을 기반으로 해시값 생성
	- 올바른 객체 검색을 위해서는 오버라이드 필요

---
**call by value**

- 값을 복사하여 처리하는 방식
- 원래 값이 수정되지 않음
- 다른 메모리 위치에 생성
- Java에서 객체를 전달하여도 실제로 전달되는 것은 객체가 아닌 참조 값
- 위와 같은 이유로 주소값이 전달되어 객체의 특정 필드를 바꾸면 원래 값인 참조 값은 변경되지 않음
- 또는 넘겨받은 참조 값을 새로운 인스턴스로 생성하여 대입하면 새로운 인스턴스의 주소값이 대입
- 이 때문에 원래의 참조 값과 가르키던 객체의 정보는 변경되지 않고, 가비지 컬렉터에 의해 메모리에서 해제됨
- 이런 이유들 때문에 Java는 call by reference가 아닌 call by value라고 이야기함

---
**접근제한자**

클래스, 변수, 메서드 등에 대한 접근 권한을 설정하는데 사용
- public : 외부 접근을 허용
- protected : 동일 클래스, 동일 패키지, 하위 클래스
- default : 동일 클래스, 동일 패키지
- private : 내부접근만 허용

---
**추상 클래스와 인터페이스**

- 추상 클래스
	- 관련 클래스를 그룹화하는 경우 사용
	- 상태를 가질 수 있음
	- 다중 상속 불가능
	- 추상 메서드를 보유
	- abstract 키워드 사용
- 인터페이스
	- 공통 기능을 여러 클래스에서 구현할 때 사용
	- Java 8 부터 상수, 디폴트 메서드, 정적 메서드 사용 가능
	- 상태를 가질 수 없음
	- 추상 메서드 보유
	- 다중 구현 가능
---
**컴파일 과정**

- .java 소스 코드 작성
- 자바 컴파일러가 소스파일 컴파일 진행 - 자바 바이트 코드(.class) 
- JVM이 바이트 코드를 실행 할 때 클래스 로드가 이를 로드
- 클래스 로더는 동적로딩을 통해 필요한 클래스들을 로딩 및 링크
	- 로드 : 클래스를 메모리에 로드
	- 검증 : 바이트 코드의 안정성과 유효성 확인
	- 준비 : 클래스에 필요한 정적 변수 메모리 할당 및 기본값으로 초기화
	- 분석 : 클래스의 심볼릭 레퍼런스를 실제 메모리 주소로 변환
	- 초기화 : 정적 초기화 블록 및 정적 변수를 초기화
- 실행엔진이 JVM 메모리에 올라온 바이트 코드들을 명렁어 단위로 실행
	- 인터프리터 - 한줄씩 읽고 해석하여 실행
	- JIT 컴파일러 - 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고, 직접 실행
---
**가비지컬렉션**

JVM의 메모리 관리 방법 중 하나로 Heap영역에 동적으로 할당했던 메모리 중 더 이상 참조하지 않는 메모리 객체를 메모리에서 해제하는 작업을 수행하는 프로세스로 G1 알고리즘을 사용

- Reachable : 객체가 참조되고 있는 상태
- Unreachable : 객체가 참조되지 않고 있는 상태 - GC 대상
- 청소 방식 mark -> sweep -> compaction 
- Young Generation : Eden, Survivor 영역으로 분류 - Minor GC가 일어나는 영역
	- Eden : new를 통해 새로 생성된 객체
	- Survivor : 최소 1번 이상의 GC로 살아남은 객체 영영으로, 0과 1 중 하나는 꼭 비어있어야함
	- age 값이 임계 값에 다다르면 old 영역으로 이동 여부 결정
- old Generation : Major GC가 일어나는 영역
	- 영역이 가득차면 Major GC 발생
	- Major GC가 일어나면 STW가 발생하고 CPU에 부하를 줌
- Java 9 이상부터 G1 GC를 디폴트로 설정
	- 4GB 이상의 힙 메모리, STW 시간이 0.5초 저도 필요한 상황에 사용
	- Region : 전체 heap 영역을 체스같이 고정된 영역으로 분할하여 상황에 따라 동적으로 영역을 부여
	- 빠르게 회수하여 빈 공간을 확보 -> GC 빈도가 줄어드는 효과

---
**오버로딩/오버라이딩**

객체지향의 특징 중 다형성을 구현하는 방법의 하나
- 오버라이딩
	- 상속 관계에서 발생하는 메서드 재정의
	- 메서드명과 매개변수 등 메서드 시그니처의 변경이 발생하면 안되고, 내부 로직의 변경만 가능
	- 동적 바인딩으로 런타임 시 결정
- 오버로딩
	- 클래스 내에서 발생하는 메서드 정의 기법
	- 메서드명과 매개변수 등 메서드 시그니처의 변경이 발생가능 하며, 동일한 메서드명으로 여러 유형의 동작을 구현
	- 리턴 타입만 다르게 적용은 불가능
	- 정적 바인딩으로 컴파일 시 결정

---
**동등성/동일성**

- 동등성(Equality)
	- 내용(값)의 비교
	- 두 객체의 내용이 같은지 확인할 때 사용
	- equals() 메서드로 비교
- 동일성(Identity)
	- 참조 값 비교
	- 두 객체가 정확히 동일한 인스턴스인지 검증할 때 사용
	- == 로 비교

---
**제네릭**

클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법으로 컴파일 타임에 타입 안정성 검사를 수행하여 불필요한 캐스팅으로 인한 오버헤드를 제거한다.
- 다이아몬드 연산자에 타입을 지정
- 타입 매개변수로 전달된 타입이 해당 클래스에서 구체화를 수행
- 생성자에 타입 파라미터 생략 가능
- 참조형만 사용 가능
- 타입 파라미터 복수개 지정 가능
- 제네릭 타입 객체 생성은 불가 -> new 연산자를 통한 생성자 호출 제한
- static 멤버에 제네릭 타입을 사용할 수 없음
- extends 키워드를 통해 타입 한정 가능 -> &를 사용해 복수로 설정 가능

---

**직렬화**

Ojbect 또는 Data를 다른 컴퓨터의 시스템에서도 사용할 수 있도록 바이트 스트림 형태로 연속적인 데이터로 변환하는 포맷 변환 기술
- 메모리를 디스크에 저장하거나, 네트워크 통신에 사용하기 위한 형식으로 변환하는 것이다. 
- 특별히, **자바 직렬화**는 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술을 뜻한다.
- **반대로** 직렬화된 바이트 형태의 데이터를 다시 객체로 변환하는 과정을 '**역직렬화**'라고 합니다.
- (간단히) JVM의 메모리에 상주(힙 or 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술

Spring에서의 직렬화는 JacksonLibrary를 통해 이루어지는데 Reflection API를 통해 개발자가 정의한 클래스의
정보를 동적으로 획득하여 필드에 접근 후 해당 정보를 직렬화하여 응답한다.

주요 어노테이션은 다음과 같다.
@JsonIgnore : 직렬화 대상에서 제외하고 싶은 필드에 사용
@JsonCreator : 객체 역직렬화 시 생성자, 팩토리 메서드 선택 방식 결정 가능
@JsonProperty : Json 필드와 Java 필드 이름을 사용자가 수동으로 매핑하고 싶은 경우 사용
@JsonFormat : 날짜/시간 등의 형식 지정 및 타임존 설정 가능

---
**String과 String Pool**

- String Pool
	- 문자열 리터럴을 저장하는 독립된 영역
	- String Pool에 저장된 문자열은 불변 객체 이므로 메모리 효율을 높일 수 있음
	- 동일한 문자열이 중복 생성되지 않도록 메모리 사용을 최적화
	- GC의 대상 -> Java 7 이전까지 PermGen에 위치, Java 7 부터는 Heap 메모리 일부로 이동
- String
	- 불변 객체
		- 암호, 사용자 인증 정보 등 중요한 데이터를 저장하는데 자주 사용
		- 해시 값 캐싱 덕분에 HashMap 및 HashSet의 키로 사용 시 성능 향상
		- 스레드 안정성 확보
	- 두 가지 방식으로 생성
		- 문자열 리터럴을 사용하는 방식
			- JVM이 String pool에 동일한 문자열 존재 검사
			- 존재한다면 해당 문자열 객체의 참조 반환
			- 존재하지 않으면 새로운 문자열 객체 생성 후 풀에 추가
		- new String()을 사용하는 방식
			- 매번 새로운 문자열 객체가 생성
			- 생성된 문자열 객체는 String pool에 추가되지 않고,
			- 힙 메모리의 다른 영역에 추가
---
**String / StringBuffer / StringBuilder**

- StringBuffer와 StringBuilder
	- 문자열을 연산 할 때 주로 사용하는 자료형
	- 값이 변경될 때마다 새롭게 객체를 만드는 String보다 빠르다
	- StringBuffer
		- 멀티 스레드 환경에서 안전
		- 메서드에 synchronized 키워드 사용
		- 기본 16 버퍼 크기로 생성
	- StringBuilder
		- 멀티 스레드 환경에서 안전하지 않음
		- 문자열 파싱 성능이 가장 우수
- String
	- 불변 객체로 변경이 불가능
	- jdk 8 - char[] 배열로 구성
	- jdk 9 이후 - byte[] 배열로 구성되어 String Compacting을 통한 성능 향상(heap 공간 효율 등)
- + 연산
	- 내부적으로 StringBuilder를 생성하여 append() 수행 후 반환
	- 하지만 문자열을 반복적으로 많이 합치게 되면 성능과 메모리 효율이 떨어짐

---
**public static void main**

- Java 애플리케이션이 실행되면 제일먼저 실행하는 메서드 - 엔트리 포인트
- public으로 지정해야 JVM이 main 함수를 찾을 수 있음
- static을 붙여줘야 JVM이 인스턴스 생성 없이 main 함수를 호출
- main 메서드가 JVM에 반환해야하는 값이 없으므로 void로 지정
- String[] args는 커맨드라인 인자를 전달받기 위한 매개변수

---
**예외** : https://lealea.tistory.com/228

---
**바이트 / 문자 스트림**

- 바이트 스트림
	- Input/OutputStream 클래스 구현
	- Byte 단위로 모든 종류의 파일 데이터 처리
- 문자 스트림
	- 16비트의 유니코드 문자 단위로 처리
	- 텍스트 파일, 문자 기반 데이터 처리
	- Reader, Writer 클래스 구현

---
**객체지향 특징**

---
**Optional API**

Optinal클래스는 java8에서 도입된 Wrapper 클래스로 값이 존재할 수도 있고 없을 수도 있는 상황을 명시적으로 처리할 수 있습니다. 이를 통해 Null point Exception문제를 해결할 수 있으며, 가독성 높은 코드를 작성할 수 있습니다. Optional 메서드를 사용하여 값의 존재 여부를 체크하고 값이 없는 경우에 대한 기본 처리를 할 수 있습니다.

---
**프로세스와 스레드**

**프로세스는** 실행 중인 프로그램을 말하며

프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)를 할당받아 프로세스가 되고

프로그램을 수행하는 데 필요한 데이터와 메모리 등의 자원 그리고 쓰레드로 구성되어있다.

완벽히 독립적이기 때문에 메모리 영역(Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않습니다. 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있습니다.

  
**쓰레드는** 프로세스 내에서 **Stack**만 따로 할당 받고, 그 이외의 메모리 영역(Code, Data, Heap)영역을 공유하기 때문에 다른 쓰레드의 실행 결과를 즉시 확인할 수 있습니다.

쓰레드는 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행됩니다.

---
**Java에서 스레드 구현 방법**

**쓰레드를 구현하는 방법**은 **Thread 클래스를 상속받는 방법**과 **Runnable 인터페이스를 구현하는 방법**,  2가지가 있다.

둘 중 어느 쪽을 사용해도 별 차이는 없지만 Java에서는 다중 상속을 허용하지 않기 때문에,

Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없어서 **Runnable 인터페이스를 구현하는 방법이 일반적이다.**

Runnable  인터페이스를  구현하는 방법은 **클래스 뒤에 implements Runnable을 기재한다.**

장점으로는 재사용성이 높고  코드의  일관성을  유지할  수  있다는  장점이  있기  때문에 보다  객체지향적인 방법이라 할 수 있다.

Runnable인터페이스는 run()메소드만 정의되어 있는 간단한 인터페이스이다.

---
final / finally / finalize

- **final**은 클래스, 메소드, 변수, 인자를 선언할 때 사용할 수 있으며, 한 번만 할당하고 싶을 때 사용합니다.
	- final 변수는 한 번 초기화되면 그 이후에 변경할 수 없습니다.
    - final 메소드는 다른 클래스가 이 클래스를 상속할 때 메소드 오버라이딩을 금지합니다.
    - final 클래스는 다른 클래스에서 이 클래스를 상속할 수 없습니다.
- **finally**는 try-catch와 함께 사용되며, try-catch가 종료될 때 finally block이 항상 수행되기 때문에 마무리 해줘야 하는 작업이 존재하는 경우에 해당하는 코드를 작성해주는 코드 블록입니다.  
- **finalize**는 Object 클래스에 정의되어 있는 메소드이며, GC에 의해 호출되는 메소드로 절대 호출해서는 안되는 메소드입니다. GC가 발생하는 시점이 불분명하기 때문에 해당 메소드가 실행된다는 보장이 없고, 
- finalize() 메소드가 오버라이딩 되어 있으면 GC가 이루어질 때 바로 Garbage Collectiong 되지 않아 지연되면서 OOME(Out of Memory Exception)이 발생할 수 있기 때문에 finalize() 메소드를 오버라이딩하여 구현하는 것을 권장하지 않고 있습니다.

---
**Java 버전 차이**

- java 8
	- 인터페이스에 디폴트 메소드와 정적 메소드 추가
	- 함수형 인터페이스, 람다 표현식, 메소드 참조 기능 추가
	- 스트림 API 도입
	- 새로운 날짜 관련 라이브러리 추가
	- Optional 지원
	- 병렬 처리 지원
- java 11
	- Files 클래스에 새로운 메소드 추가
	- 컬렉션 인터페이스에 새로운 메소드 추가
	- Predicate 인터페이스에 새로운 메소드 추가
	- 람다에서 로컬 변수 Var 사용
	- 자바 파일 실행 방식 단순화

---
**Final 키워드**

- 변수, 메서드, 클래스에 사용할 수 있음
- 컴파일러 final 변수 및 메서드를 상수로 취급하고 값을 인라인하여 코드 최적화에 활용
- 또한, 컴파일러는 final 변수에 대한 값 변경을 방지
- 클래스의 경우도 상속으로 인해 구조가 변경되지 않기 때문에 JVM이 객체의 메서드 호출을 최적화

---
**리플렉션**

- 런타임에 클래스의 메타데이터를 조회하거나 수정할 수 있는 기능
- 컴파일 타임에 알 수 없었던 클래스 정보에 접근하거나 동적으로 객체를 생성
- 개발자가 생성한 객체가 어떤 타입인지 컴파일 시점에는 알 수 없기 때문에 동적으로 해결하기 위해 리플렉션 사용
- Spring 프레임워크에서는 DI 기능을 제공하기 위해 적극적으로 활용
	- private 필드는 리플렉션을 통해 접근 제한 우회
	- 필드의 타입 정보를 확인하고 DI 컨테이너에서 해당 타입에 맞는 빈을 찾아 주입

단점
- 접근 제한을 해제하는 작업이 필요하기 때문에 일반 메서드보다 성능이 저하
- 단, 스프링에서는 애플리케이션 시작 시 한번만 수행 되기 때문에 큰 영향은 없음
- 접근 제한 우회에 따른 보안 문제가 있을 수 있음

---
**람다 표현식과 외부변수**

- 람다 표현식 내부에서는 외부 변수를 변경할 수 없다
- 외부 변수 접근 시 해당 변수를 캡처하여 사용하고, 람다 표현식이 실행될 때까지도 캡처가 유효해야하기 때문에 외부 변수의 값을 변경할 수 없도록 제한
- 만약 외부 변수의 값이 변경될 수 있다면 캡처한 복사본과 실제 변수 값이 달라지는 문제가 발생할 수 있다.
- 또한, 스택 영역은 스레드별로 독립적으로 존재하기 때문에 람다 표현식이 메서드 종료 후에도 계속 실행되면 스택 영역에 변수는 이미 파기되었을 가능성이 있다.

위와 같은 이유로 일반적인 외부변수는 사용하지 못하고, final 또는 effectively final키워드를 사용해서 정의된 외부 변수만 사용가능하다.
